

\section{Umsetzung in C\texttt{++}} \label{secKernUmsetzungInCpp}

\subsection{Konzeptionelle Unterschiede}
Die in diesem Kapitel vergestellte Umsetzung implementiert nicht exakt die bisher beschriebenen Strukturen. Der erste Unterschied ist, dass die Konzepte \emph{Funktionssymbol} und \emph{Konstantensymbol} hier nicht unterschieden werden. Da der Zweck der Implementierung zudem alleine in der Vereinfachung von Ausdrücken über den Komplexen Zahlen $\mathbb C$ liegt, ist die Menge an Symbolen zudem im Code nicht generisch gehalten. Die beiden wichtigsten Arten von Symbolen für Literale sind Komplexe Zahlen $z \in \mathbb C$, sowie Zeichenketten $c_1 c_2\dots c_n$ beliebiger Länge $n$. Die einzelnen Zeichen $c_i$ stammen dabei aus dem Alphabet $\Sigma$, welches aus Klein-und Großbuchstaben des lateinischen Alphabetes, Ziffern von $0$ bis $9$, den Abostroph \verb|'| und dem Unterstrich \verb|_| besteht. Die Ausname bildet das erste Zeichen $c_1$, welches ein Klein-oder Großbuchstabe des Lateinischen Alphabetes sein muss. Zu den Zeichenketten gehören insbesondere auch die Funktionssymbole. Mit der dadurch entstehenden Möglichkeit Funktionssymbole als Werte zu behandeln, ergibt es Sinn auch Funktionsanwendungen von dynamisch bestimmten Funktionssymbolen zuzulassen. Das erste Element $f$ des Funktionsanwendungstupels $(f, \elems t 0 {n-1})$ ist in der Umsetzung also kein Symbol, sondern ein Term. Mit den bis hier diskutierten Änderungen und $\Sigma^+$ als Bezeichnung für die Menge von Zeichenketten über dem beschriebenen Alphabet $\Sigma$ sähe die idealisierte Menge aller Literale in der Umsetzung im Kontrast zu Definition \ref{defTerm} so aus:

$$T \coloneqq \Sigma^+ \cup \mathbb C \cup \curl*{(\elems t 0 n)~|~ \elems t 0 n \in T)}.$$

Die wichtigste Erweiterung der Implementierung ist allerdings die der anoymen Funktion bekannt als \emph{Lambda}. Das Lambdakalkül von Church \cite{ChurchLambda36} definiert Terme verwandt mit den in dieser Arbeit diskutierten. Der wichtigste Unterschied ist, dass keine externe Interpretation für einen gegebenden Lambdaausdruck notwendig ist. Anstatt Funktionssymbole über Namen zu identifizieren und die Abbildungsvorschrift getrennt anzugeben, ist eine Lambdafunktion $f \in \Lambda$ ausschließlich durch ihre Abbildungsvorschrift identifiziert. Church erlaubt neben der Funktionsanwendung als Term lediglich Variablensymbole  $v \in V$ und Lambdafunktionen. Soll $T$ also eine Obermenge aller Ausdrücke im Lambdakalkül werden, müsste prinzipiell nur die Lambdafunktion selbst hinzugefügt werden. Die Menge der Variablen $V$, hier als \emph{Lambdaparameter} bezeichnet wird allerdings von den bisher erlaubten Zeichenketten in $\Sigma^+$ getrennt.

Muster sind in der Umsetzung auch entsprechend flexibler, schließlich sind sie eine Obermenge der Literale. Dazu kommt die Fähigkeit, Bedingungen an Mustervariablen zu stellen, um mögliche Matches weiter einzuschränken. Eine spezielle Form dieser Einschränkung ist dabei die der \emph{Wert-Mustervariable} $w \in W$, welche versucht Matches zu finden, die in Unterkapitel \ref{subsecNormalKombinieren} erlaubt werden, also Komplexe Zahlen wieder in Rechenausdrücke zu dekonstruieren. Näher behandelt wird die Wert-Mustervariable noch im folgenden Abschnitt \ref{subsecMustervariablen}. 
Zuletzt kann die Multi-Mustervariable aus Abschnitt \ref{subsecMulti} von hier an nicht mehr nur als abstrakte Idee gehandelt werden. Die Menge der Multi-Mustervariablen wird dementsprechend $X^*$ genannt. Zuletzt werden nur noch bindende Instanzen einer normalen Mustervariable der Menge $X$ zugeordnet, gebundene Instanzen sind Element einer neuen Menge $X'$.

\begin{definition}
Die Menge der Terme $T$ ist in diesem Kapitel definiert als
$$T \coloneqq \Sigma^+ \cup \mathbb C \cup X \cup X' \cup X^* \cup W \cup V \cup \Lambda \cup \curl*{(\elems t 0 n)~|~ \elems t 0 n \in T, n > 0)}$$
mit
\begin{align*}
    \Sigma^+  &\coloneqq \text{Zeichenketten}\\
    \mathbb C &\coloneqq \text{Komplexe Zahlen}\\
    X         &\coloneqq \text{bindende Mustervariablen}\\
    X'        &\coloneqq \text{gebundene Mustervariablen}\\
    X^*       &\coloneqq \text{Multi-Mustervariablen}\\
    W         &\coloneqq \text{Wert-Mustervariablen}\\
    V         &\coloneqq \text{Lambdaparameter}\\
    \Lambda   &\coloneqq \text{Lambdafunktionen}.
\end{align*}
\end{definition}




\subsection{Lambdafunktionen} \label{subsecLambdafunktionen}
\BFred{TODO}


\subsection{Mustervariablen} \label{subsecMustervariablen}
\BFred{TODO}

\subsection{Syntax} \label{subsecSyntax}
In der Umsetzung wird der Termbaum immer aus einer ASCII Zeichenkette gebaut.
Solche Zeichenketten sind von hier an in \texttt{monospace} gesetzt.

\subsubsection{Funktionsanwendungen}
\begin{figure}
    \label{tabZucker}
    \centering
    \begin{tabular}{l l}
        \hline
        Normale Schreibweise & Alternative Syntax\\
        \hline \hline
        \verb|sum(x, y)|           & \verb|x + y|\\
        \verb|sum(x, prod(-1, y))| & \verb|x - y|\\
        \verb|prod(-1, x)|         & \verb|-x|\\
        \verb|prod(x, y)|          & \verb|x * y|\\
        \verb|prod(x, y)|          & \verb|x y|\\
        \verb|prod(x, pow(y, -1))| & \verb|x / y|\\
        \verb|pow(x, y)|           & \verb|x^y|\\
        \verb|cons(x, y)|           & \verb|x :: y|\\
        \verb|and(x, y)|           & \verb|x && y|\\
        \verb|or(x, y)|            & \verb!x || y!\\
        \verb|not(x)|              & \verb|!x|\\
        \verb|eq(x, y)|            & \verb|x == y|\\
        \verb|neq(x, y)|           & \verb|x != y|\\
        \verb|greater(x, y)|       & \verb|x > y|\\
        \verb|smaller(x, y)|       & \verb|x < y|\\
        \verb|greater_eq(x, y)|    & \verb|x >= y|\\
        \verb|smaller_eq(x, y)|    & \verb|x <= y|\\
        \verb|_Of_T(x, y)|         & \verb|x :y|\\
        \hline
    \end{tabular}
    \caption{alternative Syntax für bestimmte Funktionssymbole}
\end{figure}

Die bisher genutzte Schreibweise $(f, x, y, z)$ für die Funktionsanwendung des Funktionssymbols $f$ auf die Parameter $x, y, z$ wurde in Abschnitt \ref{subsecTerm} eingeführt, um den Term syntaktisch von anderen Matheausdrücken zu differenzieren. Dies ist für die Umsetzung in C\texttt{++} nicht notwendig, da von vorne herein klar ist, ob eine Zeichenkette in einen Term übersetzt wird. Aus dem Grund werden Funktionsanwendungen in der Syntax \verb|f(x, y, z)| geparst. Weiter können Funktionsanwendungen bestimmter Funktionen auch mit fest definierten Infixoperatoren geschrieben werden, siehe Tabelle \ref{tabZucker}. hervorzuheben sind dabei zwei Dinge: Zum einen wird ein Leerzeichen zwischen zwei Termen als Multiplikation interpretiert, Funktionsanwendungen dürfen also kein Leerzeichen zwischen Funktion und Parametertupel setzen. \verb|f (x)| ist dementsprechend gleichbedeutend zu \verb|prod(f, x)|, während \verb|f (x, y)| einen Syntaxfehler darstellt. Die zweite Besonderheit ist das Fehlen von Funktionssymbolen für die Darstellung des additiven Inversen und des multiplikativen Inversen. Dies reduziert die Anzahl der Ersetzungsregeln, die benötigt werden um eine Gesetzmäßigkeit, die Summen oder Produkte involviert abzubilden. 

\subsubsection{Lambdafunktionen}
Da der ASCII Zeichensatz keine griechischen Buchstaben enthält, wird anstelle des kleinen Lambdas $\lambda$ der umgekehrte Schrägstrich \verb~\ ~genutzt. Die Identitätsfunktion $\lambda x.x$ wird dementsprechend \verb~\x .x~ geschrieben. Mehrere Parameter werden durch Leerzeichen getrennt: \verb~\x y .pow(x, y)~ ist eine Lambdafunktion mit identischem Verhalten zum Funktionssymbol \verb|pow|.

\subsubsection{Symbole}
Komplexe Zahlen auf der reellen Achse sind in der Syntax vergleichbar mit Darstellungen für Integer und Fließkommazahlen erlaubt in C. Möglich sind etwa \verb|42|, \verb|3.1415|, \verb|1.337e3|, \verb|1.602e-19| oder \verb|1e+10|. Komplexe Zahlen auf der imaginären Achse sind in der Struktur identisch, allerdings immer direkt gefolgt vom Zeichen \verb|i|. 

Die verschiedenen Mustervariablen werden auch unterschiedliche Weise identifiziert. Eine normale Mustervariable muss mit einem Unterstrich beginnen (\verb|_x|), eine Wert-Mustervariable mit einem Dollar (\verb|$x|) und eine Multi-Mustervariable endet in drei Punkten (\verb|xs...|). Besitzt eine Zeichenfolge aus Zeichen in $\Sigma$ keiner dieser besonderen Merkmale, wird daraus kontextabhängig ein Lambdaparameter oder ein Symbol aus $\Sigma^+$. Bindet ein umschließendes Lambda bereits den Name, wird die innerste Bindung des Namens als Lambdaparameter gewählt. 
\subsection{Datenstruktur}


Die C\texttt{++} Implementierung ist nicht nur nicht generisch in ihren Mengen $F$ und $C$, sondern unterscheidt zudem auf der Typebene nicht zwischen den beiden. Konkret ist ein Literal ein Baum, welcher als innere Knoten Funktionsanwendungen und Lambdafunktionen und als äußere Knoten Komplexe Zahlen, durch Strings identifizierte Symbole und Platzhalter für Lambda Parameter enthalten kann. 

Die Einzelnen Knoten haben dabei folgende Eigenschaften:
\begin{itemize}
\item \mintinline{cpp}{Literal::symbol} stellt ein beliebiges, dem System möglicherweise unbekanntes Symbol da. Für den Nutzer ist ein Symbol durch einen String identifiziert, welcher lateinische Großbuchstaben und Kleinbuchstaben, Dezimalziffern und Unterstriche enthalten kann, wobei das erste Zeichen keine Ziffer sein darf. Intern sind die tatsächlichen Zeichenketten nur in einer zentralen Tabelle zu finden, im einzelnen Term ist ein String durch seinen Index in dieser Tabelle beschrieben. Nachteil dieser Vorgehensweise ist, dass ohne viel organisatorischen Mehraufwand nie in der Programmlaufzeit ein Eintrag in der zentralen Namenstabelle gelöscht werden darf, da nicht klar ist, ob es noch Symbole mit diesem Namen gibt. Das ist in der Praxis allerdings kein Problem, da Symbolnamen nicht mutierbar sind, also jedes tatsächlich genutzte Symbol auch nur genau einen Eintrag produziert.
\item \mintinline{cpp}{Literal::complex} repräsentiert eine Instanz von \mintinline{cpp}{std::complex<double>}, also ein Paar aus zwei 64-bit Fließkommazahlen, welche eine Komplexe Zahl in karthesischen Koordinaten annähren. Für ein Computeralgebrasystem ist die Nutzung von Fließkommazahlen problematisch, da (sofern nicht anders gewünscht) nur exakte Transformationen durchgeführt werden sollen. Der haupsächliche Grund in der Nutzung liegt darin, dass grundlegende Operationen und einige Funktionen wie Sinus und Cosinus bereits in der Standardbibliothek definiert sind. 
\item \mintinline{cpp}{Literal::lambda} repräsentiert eine anonyme Funktion, also eine Funktion, die nur über ihre Abbildungsvorschrift definiert ist. Als Parameteranzahl erlaubt ist dabei eine natürliche Zahl $n \in [1, 2^{16} - 1]$. Speichern tut ein Lambda damit primär seine Parameteranzahl und einen Verweis auf den Term, der die Abbildungsvorschrift darstellt.
\item \mintinline{cpp}{Literal::lambda_param} ist der Platzhalter, der in der Definition der Abbildungsvorschrift eines Lambdas für einen bestimmten Parameter steht. Identifiziert wird der einzelne Parameter dabei durch einen Index.
\item \mintinline{cpp}{Literal::f_app} Entspricht der Funktionsanwendung aus vorrangegangenden Abschnitten, ist also ein Tupel aus Verweisen auf weitere Knoten, wobei der erste Verweis als anzuwendene Funktion interpretiert wird, alle weiteren Verweise als Parameter.
\end{itemize}

\begin{listing}
\small
\begin{minted}[linenos=true]{cpp}
enum class Literal
{
    symbol,
    complex,
    lambda,
    lambda_param,
    f_app,
};
\end{minted}
\label{abbLiteralEnum}
\caption{Mögliche Knotentypen in einem Literal}
\end{listing}

\subsection{Konkrete Datenstruktur} \label{subsecKonkreteDatenstruktur}
%TODO: huebsche bäume zum veranschaulichen

Problem beim Speichern eines Terms ist die möglicherweise erst zur Laufzeit bekannte Parameteranzahl der einzelnen Funktionsanwendung. Die Matchalgorithmen aus Abschnitt \ref{secPattermatching} greifen auf die einzelnen Parameter in nicht immer vorhersehbarer Reihenfolge zu, weswegen dieser Zugriff möglichst schnell erfolgen können sollte. Eine verkettete Liste macht zwar das speichern beliebig vieler Parameter trivial, erlaubt aber keinen schnellen Zugriff auf beliebige Elemente. Die C\texttt{++} Standardbibliothek enthält \mintinline{cpp}{std::vector} zur Lösung ähnlicher Probleme einen Datentyp zur Verwaltung von Arrays veränderbarer Größe auf dem Heap. Eine Möglichkeit wäre also eine klassische Pointerstruktur mit \mintinline{cpp}{std::vector} als Knoten zu konstruieren. Ein Nachteil dieser Lösung ist die doppelte Indirektion in der Verwaltung: Der Pointer zu einer Funktionsanwendung zeigt in dem Fall zur Verwaltungsstruktur des Vektors, welche selbst erst den Pointer auf die Parameter enthält. Ein zweiter Nachteil wäre, dass die Information über den Typ eines Terms nur indirekt über virtuelle Funktionen abgerufen werden können würde. 


In der implementierten Variante sind die Knoten eines Termbaumes in einem Array gespeichert, wobei dem einzelnen Arrayelement nicht zu entnehmen ist, welche Art Knoten es repräsentiert. Ein Verweis auf einen Knoten beinhaltet also nicht nur den Arrayindex, sondern auch den Knotentyp. Als Paar zusammengefasst sind beide in der Klasse \mintinline{cpp}{NodeIndex}. 
Da die Knotentypen \mintinline{cpp}{Literal::symbol} und \mintinline{cpp}{Literal::lambda_param} durch einen vorzeichenlosen Integer bereits eindeutig dargestellt werden können, hat der Index einer \mintinline{cpp}{NodeIndex} Instanz für diese Typen nicht die Bedeutung eines Arrayindex, sondern ist direkt die komplette Beschreibung des Knoteninhaltes.


\subsection{Muster} \label{subsecCppMuster}
%TODO

\subsection{Musteranwendung} \label{subsecCppMusterAnwendung}
%TODO




















\section{Umsetzung in C\texttt{++}} \label{secKernUmsetzungInCpp}

%.........................................................................
%.........................................................................
%.........................................................................
\subsection{Konzeptionelle Unterschiede}
Die in diesem Kapitel vergestellte Umsetzung implementiert nicht exakt die bisher beschriebenen Strukturen. Der erste Unterschied ist, dass die Konzepte \emph{Funktionssymbol} und \emph{Konstantensymbol} hier nicht unterschieden werden. Da der Zweck der Implementierung zudem alleine in der Vereinfachung von Ausdrücken über den Komplexen Zahlen $\mathbb C$ liegt, ist die Menge an Symbolen zudem im Code nicht generisch gehalten. Die beiden wichtigsten Arten von Symbolen für Literale sind Komplexe Zahlen $z \in \mathbb C$, sowie Zeichenketten $c_1 c_2\dots c_n$ beliebiger Länge $n$. Die einzelnen Zeichen $c_i$ stammen dabei aus dem Alphabet $\Sigma$, welches aus Klein-und Großbuchstaben des lateinischen Alphabetes, Ziffern von $0$ bis $9$, den Abostroph \verb|'| und dem Unterstrich \verb|_| besteht. Die Ausname bildet das erste Zeichen $c_1$, welches ein Klein-oder Großbuchstabe des Lateinischen Alphabetes sein muss. Zu den Zeichenketten gehören insbesondere auch die Funktionssymbole. Mit der dadurch entstehenden Möglichkeit Funktionssymbole als Werte zu behandeln, ergibt es Sinn auch Funktionsanwendungen von dynamisch bestimmten Funktionssymbolen zuzulassen. Das erste Element $f$ des Funktionsanwendungstupels $(f, \elems t 0 {n-1})$ ist in der Umsetzung also kein Symbol, sondern ein Term. Mit den bis hier diskutierten Änderungen und $\Sigma^+$ als Bezeichnung für die Menge von Zeichenketten über dem beschriebenen Alphabet $\Sigma$ sähe die idealisierte Menge aller Literale in der Umsetzung im Kontrast zu Definition \ref{defTerm} so aus:

$$T \coloneqq \Sigma^+ \cup \mathbb C \cup \curl*{(\elems t 0 n)~|~ \elems t 0 n \in T)}.$$

Die wichtigste Erweiterung der Implementierung ist allerdings die der anoymen Funktion bekannt als \emph{Lambda}. Das Lambdakalkül von Church \cite{ChurchLambda36} definiert Terme verwandt mit den in dieser Arbeit diskutierten. Der wichtigste Unterschied ist, dass keine externe Interpretation für einen gegebenden Lambdaausdruck notwendig ist. Anstatt Funktionssymbole über Namen zu identifizieren und die Abbildungsvorschrift getrennt anzugeben, ist eine Lambdafunktion $f \in \Lambda$ ausschließlich durch ihre Abbildungsvorschrift identifiziert. Church erlaubt neben der Funktionsanwendung als Term lediglich Variablensymbole  $v \in V$ und Lambdafunktionen. Soll $T$ also eine Obermenge aller Ausdrücke im Lambdakalkül werden, müsste prinzipiell nur die Lambdafunktion selbst hinzugefügt werden. Die Menge der Variablen $V$, hier als \emph{Lambdaparameter} bezeichnet wird allerdings von den bisher erlaubten Zeichenketten in $\Sigma^+$ getrennt.

Muster sind in der Umsetzung auch entsprechend flexibler, schließlich sind sie eine Obermenge der Literale. Dazu kommt die Fähigkeit, Bedingungen an Mustervariablen zu stellen, um mögliche Matches weiter einzuschränken. Eine spezielle Form dieser Einschränkung ist dabei die der \emph{Wert-Mustervariable} $w \in W$, welche versucht Matches zu finden, die in Unterkapitel \ref{subsecNormalKombinieren} erlaubt werden, also Komplexe Zahlen wieder in Rechenausdrücke zu dekonstruieren. Näher behandelt wird die Wert-Mustervariable noch im folgenden Abschnitt \ref{subsecMustervariablen}. 
Zuletzt kann die Multi-Mustervariable aus Abschnitt \ref{subsecMulti} von hier an nicht mehr nur als abstrakte Idee gehandelt werden. Die Menge der Multi-Mustervariablen wird dementsprechend $X^*$ genannt. 

\begin{definition}
Die Menge der Terme $T$ ist in diesem Kapitel definiert als
$$T \coloneqq \Sigma^+ \cup \mathbb C \cup X \cup X' \cup X^* \cup W \cup V \cup \Lambda \cup \curl*{(\elems t 0 n)~|~ \elems t 0 n \in T, n > 0)}$$
mit
\begin{align*}
    \Sigma^+  &\coloneqq \text{Zeichenketten}\\
    \mathbb C &\coloneqq \text{Komplexe Zahlen}\\
    X         &\coloneqq \text{Mustervariablen}\\
    X^*       &\coloneqq \text{Multi-Mustervariablen}\\
    W         &\coloneqq \text{Wert-Mustervariablen}\\
    V         &\coloneqq \text{Lambdaparameter}\\
    \Lambda   &\coloneqq \text{Lambdafunktionen}.
\end{align*}
\end{definition}




%.........................................................................
%.........................................................................
%.........................................................................
\subsection{Lambdafunktionen} \label{subsecLambdafunktionen}
Die umgesetzten Funktionen erweitern die Definition von Church, indem die selbe Lambdaabstraktion auch mehrere Parameter erlaubt. Während der Ausdruck $\lambda x_0 y_1 . x_0(y_1)$ für Church also nur eine vereinfachte Schreibweise\footnote{Die Klammern um $y$ werden in der Literatur oft weggelassen, für diese Arbeit sind sie allerdings notwendig.} für den Ausdruck $\lambda x_0 .\lambda y_1 .x_0(y_1)$ darstellt, handelt es sich für die hier berschriebende Umsetzung um zwei verschiedene Funktionen. 
Ein Lambdaparameter ist in der Syntax nicht von anderen Symbolen unterscheidbar\footnote{siehe \ref{subsubsecLambdaSyntax}}, wird intern allerdings mit einer Variante der De Bruijn Indices dargestellt \cite{deBruijn}.
 Jeder neu gebundene Parameter bekommt als Index die Zahl der weiter außen bzw. in der selben Abstraktion vor ihm gebundenen Parameter. Zur Veranschaulichung wird hier der Index im Tiefsatz mitgeschrieben. 
 Als Beispiel dient $\lambda x_0 y_1 .\lambda z_2 .x_0 + y_1 + z_2$. Das Zeichen $x$ wird in der äußersten Abstraktion zuerst gebunden, hat also keine Vorgänger und dementsprechend Index $0$. In der selben Abstraktion wird als zweiter Parameter weiter $y$ gebunden. Als Nachfolger von $x$ wird $y$ Index $1$ zugewiesen. Die Bindung von $z$ liegt Innerhalb der Abbildungsvorschrift des äußeren Lambdas, $x$ und $y$ können also referenziert werden. Dementsprechend hat $z$ zwei Vorgänger und Index $2$. 
 
 Die Auswertung der Funktionsanwendung einer Lambdafunktion $f$ entspricht der $\beta$-Redunktion (von Church \cite{ChurchLambda36} als \emph{operation II} bezeichnet). Parameter von $f$ werden dafür durch die übergebenden Argumente ersetzt. Enthält die Definition von $f$ allerdings weitere Lambdaabstraktionen, so werden die Indices derer Parameter nur um die Stelligkeit von $f$ erniedrigt.
 Als Beispiel wird der Ausdruck $(\lambda x_0 .\lambda y_1 .x_0 + y_1)(3)$ zum Ausdruck $\lambda y_0 .3 + y_0$ ausgewertet\footnote{die Namen der Variablen $x$ und $y$ sind dem System dabei nicht bekannt, lediglich die Indices $0$ und $1$ identifizieren die Parameter.}.
 
 Enthält ein Argument $a$ der Funktionsanwendung einer Lambdafunktion $f$ allerdings selbst eine Lambdafunktion $g$, so reicht es mit bisher diskutierten Konzepten im allgemeinen Fall nicht aus, den entsprechenden Parameter von $f$ einfach durch $a$ zu ersetzen: Sollte diese Ersetzung innerhalb einer Lambdaabstraktion $f'$ stattfinden, haben die Parameter von $g$ einen jetzt falschen Index und werden mindestens teilweise fälschlicherweise $f'$ zugeordnet. Als Beispiel ist $a = g = \lambda x_0 .x_0$ die Identität, welche der Funktion $f = \lambda x_0 .\lambda y_1 .x_0(y_1)$ übergeben wird.
 $$(\lambda x_0 .\lambda y_1 .x_0(y_1))(\lambda x_0 .x_0)$$
 Die Naive Ersetzung von $x_0$ in $f$ durch $g$ würde im folgenden Ausdruck resultieren\footnote{Die Darstellung ist in sofern problematisch, als Dank der De Bruijn Indizierung die Lambdaabstraktion keine explizite Bindung einzelner Variablen mehr enthält, lediglich wie viele Variablen gebunden werden.}.
 $$\lambda y_0 .(\lambda x_0 .x_0)(y_0)$$
Da die Namen $x$ und $y$ nur der Veranschaulichung dienen und nicht tatsächlich zur Unterscheidung genutzt werden können, ist der Ausdruck identisch zu $\lambda y_0 .(\lambda x_1 .y_0)(y_0)$.
Um dieses Problem zu lösen, ist eine Option bei der Ersetzung der Lambdaparameter durch die Argumente für jede Ersetzung innerhalb einer weiteren Lambdaabstraktion die Indices von Lamndaparametern im Argument entsprechend anzupassen. Das würde allerdings bedeuten, dass die Komplexität der Auswertung von der Größe der Argumente abhängig ist. Die Alternative ist die Unterscheidung zwischen sogenannten \emph{transparenten} Lambdas und \emph{nicht-transparenten} Lambdas, zweitere dargestellt durch umschließende geschweifte Klammern: $\{f\}$. In ersteren werden bei einer Auswertung Parameter wie beschrieben ersetzt, in zweiteren nicht. Wenn jede äußerste Lambdaabstraktion immer nicht-transparent ist, ist das Problem umgangen. Im bereits behandelten Problemfall werden $f$ und $g$ damit nicht-transparent. Lediglich $f'$ ist zu Beginn transparent, wird allerdings nach Auswertung von $f$ ebendfalls zur äußersten Lambdaabstraktion, verliert also seine Transparenz. 
\begin{align*}
    ~      &~\{\lambda x_0 .\lambda y_1 .x_0(y_1)\}(\{\lambda x_0 .x_0\})(3) \\
    \mapsto&~\{\lambda y_0 .\{\lambda x_0 .x_0\}(y_0)\}(3)\\
    \mapsto&~\{\lambda x_0 .x_0\}(3)\\
    \mapsto&~3
\end{align*}


%.........................................................................
%.........................................................................
%.........................................................................
\subsection{Mustervariablen} \label{subsecMustervariablen}


%.........................................................................
%.........................................................................
%.........................................................................
\subsection{Syntax} \label{subsecSyntax}
In der Umsetzung wird der Termbaum immer aus einer ASCII Zeichenkette gebaut.
Solche Zeichenketten sind von hier an in \texttt{monospace} gesetzt.

\subsubsection{Funktionsanwendungen}
\begin{figure}
    \label{tabZucker}
    \centering
    \begin{tabular}{l l}
        \hline
        Normale Schreibweise & Alternative Syntax\\
        \hline \hline
        \verb|sum(x, y)|           & \verb|x + y|\\
        \verb|sum(x, prod(-1, y))| & \verb|x - y|\\
        \verb|prod(-1, x)|         & \verb|-x|\\
        \verb|prod(x, y)|          & \verb|x * y|\\
        \verb|prod(x, y)|          & \verb|x y|\\
        \verb|prod(x, pow(y, -1))| & \verb|x / y|\\
        \verb|pow(x, y)|           & \verb|x^y|\\
        \verb|cons(x, y)|           & \verb|x :: y|\\
        \verb|and(x, y)|           & \verb|x && y|\\
        \verb|or(x, y)|            & \verb!x || y!\\
        \verb|not(x)|              & \verb|!x|\\
        \verb|eq(x, y)|            & \verb|x == y|\\
        \verb|neq(x, y)|           & \verb|x != y|\\
        \verb|greater(x, y)|       & \verb|x > y|\\
        \verb|smaller(x, y)|       & \verb|x < y|\\
        \verb|greater_eq(x, y)|    & \verb|x >= y|\\
        \verb|smaller_eq(x, y)|    & \verb|x <= y|\\
        \verb|of_type__(x, y)|     & \verb|x :y|\\
        \hline
    \end{tabular}
    \caption{alternative Syntax für bestimmte Funktionssymbole}
\end{figure}

Die bisher genutzte Schreibweise $(f, x, y, z)$ für die Funktionsanwendung des Funktionssymbols $f$ auf die Parameter $x, y, z$ wurde in Abschnitt \ref{subsecTerm} eingeführt, um den Term syntaktisch von anderen Ideen zu differenzieren. Dies ist für die Umsetzung in C\texttt{++} nicht notwendig, da von vorne herein klar ist, ob eine Zeichenkette in einen Term übersetzt wird. Aus dem Grund werden Funktionsanwendungen in der Syntax \verb|f(x, y, z)| geparst. Weiter können Funktionsanwendungen bestimmter Funktionen auch mit fest definierten Infixoperatoren geschrieben werden, siehe Tabelle \ref{tabZucker}. hervorzuheben sind dabei zwei Dinge: Zum einen wird ein Leerzeichen zwischen zwei Termen als Multiplikation interpretiert, Funktionsanwendungen dürfen also kein Leerzeichen zwischen Funktion und Parametertupel setzen. \verb|f (x)| ist dementsprechend gleichbedeutend zu \verb|prod(f, x)|, während \verb|f (x, y)| einen Syntaxfehler darstellt. Die zweite Besonderheit ist das Fehlen von Funktionssymbolen für die Darstellung des additiven Inversen und des multiplikativen Inversen. Dies reduziert die Anzahl der Ersetzungsregeln, die benötigt werden um eine Gesetzmäßigkeit, die Summen oder Produkte involviert abzubilden. 

\subsubsection{Lambdafunktionen} \label{subsubsecLambdaSyntax}
Da der ASCII Zeichensatz keine griechischen Buchstaben enthält, wird anstelle des kleinen Lambdas $\lambda$ der umgekehrte Schrägstrich \verb~\ ~genutzt. Die Identitätsfunktion $\lambda x.x$ wird dementsprechend \verb~\x .x~ geschrieben. Mehrere Parameter werden durch Leerzeichen getrennt: \verb~\x y .pow(x, y)~ ist eine Lambdafunktion mit identischem Verhalten zum Funktionssymbol \verb|pow|.

\subsubsection{Symbole}
Komplexe Zahlen auf der reellen Achse sind in der Syntax vergleichbar mit Darstellungen für Integer und Fließkommazahlen erlaubt in C. Möglich sind etwa \verb|42|, \verb|3.1415|, \verb|1.337e3|, \verb|1.602e-19| oder \verb|1e+10|. Komplexe Zahlen auf der imaginären Achse sind in der Struktur identisch, allerdings immer direkt gefolgt vom Zeichen \verb|i|. 

Die verschiedenen Mustervariablen werden auch unterschiedliche Weise identifiziert. Eine normale Mustervariable muss mit einem Unterstrich beginnen (\verb|_x|), eine Wert-Mustervariable mit einem Dollar (\verb|$x|) und eine Multi-Mustervariable endet in drei Punkten (\verb|xs...|). Besitzt ein Name keiner dieser besonderen Merkmale, wird daraus kontextabhängig ein Lambdaparameter oder ein Symbol aus $\Sigma^+$. Ist der umgebende Name bereits in einem umschließenden Lambda gebunden, wird die innerste solche Bindung gewählt. Als Beispiel ist im Ausdruck \verb|\x .x + y| das Symbol \verb|x| als Lambdaparameter interpretiert, während \verb|y| Als Zeichenkette erhalten bleibt.
Im Ausdruck \verb|\x .\x .2 - x| kann der Parameter \verb|x| des äußeren Lambdas in der Definition des inneren Lambdas nicht mehr referenziert werden, der Gesamtausdruck ist damit identisch zu \verb|(\x .(\y .2 - y))|.


%.........................................................................
%.........................................................................
%.........................................................................
\subsection{Datenstruktur}
\BFred{TODO}

%.........................................................................
%.........................................................................
%.........................................................................
\subsection{Algorithmen} \label{subsecCppAlgos}
\BFred{TODO}



















\chapter{Umsetzung} \label{secKernUmsetzungInCpp}

Der gesamte Quelltext der Umsetzung in C\texttt{++} ist auf GitHub einsehbar \cite{brunizzl2021Jul}. Hier gezeigte Ausschnitte sind teilweise gekürzt.
Dieses Kapitel hat keinen Anspruch auf Vollständigkeit. Der Fokus liegt darauf, die theoretisch ausführlich beschriebenen Konzepte in der Praxis zu zeigen und die wichtigsten bisher in dieser Arbeit unbehandelten Ideen vorzustellen. Aufgrund der gegenseitigen Abhängigkeit der verschiedenen Ideen sollten die Abschnitte \ref{subsecKonzeptionelleUnterschiede} und \ref{subsecSyntax} nicht direkt mit dem Anspruch eines lückenlosen Verständnisses gelesen werden, da die darauf folgenden Abschnitte noch weiter ins Detail gehen.

%.........................................................................
%.........................................................................
%.........................................................................
\section{Konzeptionelle Unterschiede} \label{subsecKonzeptionelleUnterschiede}
Die Umsetzung implementiert nicht exakt die bisher beschriebenen Strukturen. Der erste Unterschied ist, dass die Mengen der Funktionssymbole $F$ und der Konstantensymbole $C$ hier nicht unterschieden werden. Da der Zweck der Implementierung alleine in der Vereinfachung von Ausdrücken über den Komplexen Zahlen $\mathbb C$ liegt, ist die Menge an Symbolen zudem im Code nicht generisch gehalten. Die beiden wichtigsten Arten von Symbolen für Literale sind Komplexe Zahlen $z \in \mathbb C$, sowie Zeichenketten $c_1 c_2\dots c_n$ beliebiger Länge $n$. Die einzelnen Zeichen $c_i$ stammen dabei aus dem Alphabet $\Sigma$, welches aus Klein-und Großbuchstaben des lateinischen Alphabetes, Ziffern von $0$ bis $9$, dem Apostroph \verb|'| und dem Unterstrich \verb|_| besteht. Die Ausnahme bildet das erste Zeichen $c_1$, welches ein Klein- oder Großbuchstabe des Lateinischen Alphabetes sein muss. Zu den Zeichenketten gehören insbesondere auch die Funktionssymbole. Mit der dadurch entstehenden Möglichkeit, Funktionssymbole als Werte zu behandeln, ergibt es Sinn, auch Funktionsanwendungen von dynamisch bestimmten Funktionssymbolen zuzulassen. Das erste Element $f$ des Funktionsanwendungstupels $(f, \elems t 0 {n-1})$ ist in der Umsetzung deshalb kein Symbol, sondern ein Term. Mit den bis hier diskutierten Änderungen und $\Sigma^+$ als Bezeichnung für die Menge von Zeichenketten über dem beschriebenen Alphabet $\Sigma$, sähe die idealisierte Menge aller Literale in der Umsetzung im Gegensatz zu Definition \ref{defTerm} so aus:

$$T \coloneqq \Sigma^+ \cup \mathbb C \cup \curl*{(\elems t 0 n)~|~ \elems t 0 n \in T}.$$

Die wichtigste Erweiterung der Implementierung ist die der anonymen Funktion, bekannt als \Emph{\Gls{Lambda}}. Das Lambdakalkül von Church \cite{ChurchLambda36} definiert Terme verwandt mit den in dieser Arbeit diskutierten. Der wichtigste Unterschied zum bisherigen Funktionssymbol ist, dass keine externe Interpretation für einen gegebenen Lambdaausdruck notwendig ist. Anstatt Funktionssymbole über Namen zu identifizieren und die Abbildungsvorschrift getrennt anzugeben, ist eine Lambdafunktion $f \in \Lambda$ ausschließlich durch ihre Abbildungsvorschrift identifiziert. Church erlaubt neben der Funktionsanwendung als Term lediglich Variablensymbole  $v \in V$ und Lambdafunktionen. Soll $T$ also eine Obermenge aller Ausdrücke im Lambdakalkül werden, müsste prinzipiell nur die Lambdafunktion selbst hinzugefügt werden. Die Menge der Variablen $V$, hier als \Emph{\Gls{Lambdaparameter}} bezeichnet, wird allerdings von den bisher erlaubten Zeichenketten in $\Sigma^+$ getrennt.

Muster sind auch in der Umsetzung eine Obermenge der Literale. 
Neben den weiteren dadurch entstehenden Formulierungsmöglichkeiten, kommt die Fähigkeit, Bedingungen an Mustervariablen zu stellen, um mögliche Matches weiter einzuschränken. 
Eine spezielle Form dieser Einschränkung ist dabei die der \Emph{\Gls{Wert-Mustervariable}} $w \in W$, welche versucht, Matches zu finden, die in Abschnitt \ref{subsecNormalKombinieren} erlaubt werden, also Komplexe Zahlen wieder in Rechenausdrücke zu dekonstruieren. Näher behandelt wird die Wert-Mustervariable noch in Abschnitt \ref{subsecMustervariablen}. 
Zuletzt kann die Multi-Mustervariable aus Abschnitt \ref{subsecMulti} von hier an nicht mehr nur als abstrakte Idee gehandelt werden. Die Menge der Multi-Mustervariablen wird $X^*$ genannt. 

\begin{definition} \label{defKnotentypenMathe}
Die Menge der Terme $T$ ist in diesem Kapitel definiert als
$$T \coloneqq \Sigma^+ \cup \mathbb C \cup X \cup X' \cup X^* \cup W \cup V \cup \Lambda \cup \curl*{(\elems t 0 n)~|~ \elems t 0 n \in T}$$
mit
\begin{align*}
    \Sigma^+  &\coloneqq \text{Zeichenketten}\\
    \mathbb C &\coloneqq \text{Komplexe Zahlen}\\
    X         &\coloneqq \text{Mustervariablen}\\
    X^*       &\coloneqq \text{Multi-Mustervariablen}\\
    W         &\coloneqq \text{Wert-Mustervariablen}\\
    V         &\coloneqq \text{Lambdaparameter}\\
    \Lambda   &\coloneqq \text{Lambdafunktionen}.
\end{align*}
\end{definition}






%.........................................................................
%.........................................................................
%.........................................................................
\section{Syntax} \label{subsecSyntax}
In der Umsetzung wird der Termbaum immer aus einer ASCII Zeichenkette gebaut.
Solche Zeichenketten sind von hier an in \texttt{monospace} gesetzt. Auf eine formale Definition der genutzten Grammatik wird verzichtet.

\subsection{Funktionsanwendungen}
\begin{figure}
    \centering
    \begin{tabular}{l l}
        \hline
        Normale Schreibweise & Alternative Syntax\\
        \hline \hline
        \verb|prod(-1, x)|         & \verb|-x|\\
        \verb|not(x)|              & \verb|!x|\\
        \verb|pow(x, y)|           & \verb|x^y|\\
        \verb|prod(x, y)|          & \verb|x * y|\\
        \verb|prod(x, y)|          & \verb|x y|\\
        \verb|prod(x, pow(y, -1))| & \verb|x / y|\\
        \verb|sum(x, y)|           & \verb|x + y|\\
        \verb|sum(x, prod(-1, y))| & \verb|x - y|\\
        \verb|cons(x, y)|          & \verb|x :: y|\\
        \verb|eq(x, y)|            & \verb|x == y|\\
        \verb|neq(x, y)|           & \verb|x != y|\\
        \verb|greater(x, y)|       & \verb|x > y|\\
        \verb|smaller(x, y)|       & \verb|x < y|\\
        \verb|greater_eq(x, y)|    & \verb|x >= y|\\
        \verb|smaller_eq(x, y)|    & \verb|x <= y|\\
        \verb|and(x, y)|           & \verb|x && y|\\
        \verb|or(x, y)|            & \verb!x || y!\\
        \verb|of_type__(x, y)|     & \verb|x :y|\\
        \hline
    \end{tabular}
    \caption{alternative Syntax für bestimmte Funktionssymbole}
    \label{tabZucker}
\end{figure}

Die bisher genutzte Schreibweise $(f, x, y, z)$ für die Funktionsanwendung des Funktionssymbols $f$ auf die Parameter $x, y, z$ wurde in Abschnitt \ref{subsecTerm} eingeführt, um den Term syntaktisch von anderen Ideen zu differenzieren. Dies ist für die Umsetzung in C\texttt{++} nicht notwendig, da hier durch den Kontext klar ist, ob eine Zeichenkette in einen Term übersetzt wird. Aus dem Grund werden Funktionsanwendungen in der Syntax \verb|f(x, y, z)| geparst. 
Weiter können Funktionsanwendungen bestimmter Funktionen auch mit fest definierten Infixoperatoren geschrieben werden, siehe Tabelle \ref{tabZucker}. Die Bindekraft der Operatoren nimmt in der Tabelle von oben nach unten ab.
Aus der Tabelle hervorzuheben sind zwei Dinge: Zum einen wird ein Leerzeichen zwischen zwei Termen als Multiplikation interpretiert, Funktionsanwendungen dürfen also kein Leerzeichen zwischen Funktion und Parametertupel setzen. Der Ausdruck \verb|f (x)| ist dementsprechend gleichbedeutend zu \verb|prod(f, x)|, während \verb|f (x, y)| einen Syntaxfehler darstellt. Zum anderen fehlen Funktionssymbole für die Darstellung des additiven Inversen und des multiplikativen Inversen. Dies reduziert die Anzahl der Ersetzungsregeln, die benötigt werden, um eine Gesetzmäßigkeit, die Summen oder Produkte involviert, abzubilden. 

\subsection{Lambdafunktionen} \label{subsubsecLambdaSyntax}
Da der ASCII Zeichensatz keine griechischen Buchstaben enthält, wird anstelle des kleinen Lambdas $\lambda$ der umgekehrte Schrägstrich \verb~\ ~genutzt. Die Identitätsfunktion $\lambda x.x$ wird dementsprechend \verb~\x .x~ geschrieben. Mehrere Parameter werden durch Leerzeichen getrennt: \verb~\x y .pow(x, y)~ ist eine Lambdafunktion mit identischem Verhalten zum Funktionssymbol \verb|pow|.

\subsection{Symbole}
Komplexe Zahlen auf der reellen Achse sind in der Syntax vergleichbar mit Darstellungen für Integer und Fließkommazahlen erlaubt in C. Möglich sind etwa \verb|3.1415|, \verb|42|, \verb|1.337e3| oder \verb|1.602e-19|. Komplexe Zahlen auf der imaginären Achse sind in der Struktur identisch, allerdings immer direkt gefolgt vom Zeichen \verb|i|. 

Die verschiedenen Mustervariablen werden auf unterschiedliche Weise identifiziert. Eine normale Mustervariable muss mit einem Unterstrich beginnen (\verb|_x|), eine Wert-Mustervariable mit einem Dollar (\verb|$x|) und eine Multi-Mustervariable endet in drei Punkten (\verb|xs...|). Besitzt ein Name keines dieser besonderen Merkmale, wird daraus kontextabhängig ein Lambdaparameter oder ein Symbol aus $\Sigma^+$. Ist der umgebende Name bereits in einem umschließenden Lambda gebunden, wird die innerste Bindung gewählt. Als Beispiel ist im Ausdruck \verb|\x .x + y| das Symbol \verb|x| als Lambdaparameter interpretiert, während \verb|y| als Zeichenkette erhalten bleibt.
Im Ausdruck \verb|\x .\x .2 - x| kann der Parameter \verb|x| des äußeren Lambdas in der Definition des inneren Lambdas nicht mehr referenziert werden. Der Gesamtausdruck ist damit identisch zu \verb|(\x .(\y .2 - y))|.

\subsection{Literale}
Ein Literal kann Lambdafunktionen, Funktionsanwendungen, Komplexe Zahlen und Symbole aus $\Sigma^+$ enthalten. Abbildung \ref{figBspLit} enthält Beispiele.

\begin{figure}
\begin{unbreakable}\begin{verbatim}
1 + a

sin(3 pi / 2 t) + 5 cos(pi / 8 t)

map(tup, \x .x^2, tup(1, 2, 3))
\end{verbatim}\end{unbreakable}
\caption{Beispiele für Literale}
\label{figBspLit}
\end{figure}

\subsection{Ersetzungsregeln}
Es gibt zwei Varianten Ersetzungsregeln zu schreiben.
\begin{align*}
	~&~&~&~&\textit{<linke Seite>}&~ ~                       &\verb~=    ~ \textit{<rechte Seite>}&~&~&~&~\\
	~&~&~&~&\textit{<linke Seite>}&~\verb~|~~\textit{<Bedingungen>} &\verb~=    ~ \textit{<rechte Seite>}&~&~&~&~
\end{align*}
In der zweiten Variante ist \textit{<Bedingungen>} eine kommaseparierte Liste von Bedingungen an die vorkommenden Mustervariablen, wie in Abschnitt \ref{subsubsecBedingungen} diskutiert. 
Beispiele sind in Abbildung \ref{figBspRegeln} aufgeführt.

\begin{figure}
\begin{unbreakable}\begin{verbatim}
id = \x .x

0 xs... = 0

cos(($k + 1/2) pi) | $k :int = 0

change(_f, _g, _f(xs...)) = _g(xs...)

$a^2 + 2 $a _b + _b^2 = ($a + _b)^2

_aPow2 + _2a _b + _b^2 | 4 _aPow2 == _2a^2 = (1/2 _2a + _b)^2
\end{verbatim}\end{unbreakable}
\caption{Beispiele für Ersetzungsregeln}
\label{figBspRegeln}
\end{figure}
Die beiden letzten Regeln haben den exakt gleichen Effekt, wie noch in Abschnitten \ref{subsubsecWertMustervariable} und \ref{subsubsecBedingungen} erörtert. Während die vorletzte die Wert-Mustervariable \verb|$a| einsetzt, bringt die letzte Regel die Mustervariablen \verb|_aPow2| und \verb|_2a| über die angestellte Bedingung in Beziehung zueinander.



%.........................................................................
%.........................................................................
%.........................................................................
\section{Lambdafunktionen} \label{subsecLambdafunktionen}
Die umgesetzten Funktionen erweitern die Definition von Church, indem die selbe Lambdaabstraktion auch mehrere Parameter erlaubt. Während der Ausdruck $\lambda x y . x(y)$ für Church also nur eine vereinfachte Schreibweise\footnote{Die Klammern um $y$ werden in der Literatur oft weggelassen, für diese Arbeit sind sie allerdings notwendig.} für den Ausdruck $\lambda x .\lambda y .x(y)$ darstellt, handelt es sich für die hier beschriebene Umsetzung um zwei verschiedene Funktionen. 
Ein Lambdaparameter ist in der Syntax nicht von anderen Symbolen unterscheidbar\footnote{siehe \ref{subsubsecLambdaSyntax}}, wird intern jedoch durch einen Index dargestellt. Die Darstellung unterscheidet sich von De Bruijn Indizierung \cite{deBruijn} darin, dass jede Instanz der selben Variable immer den selben Index hat\footnote{Sollte eine Ersetzungsregel auch innerhalb eines Lambdas anwendbar sein, ist eine solche Herangehensweise vorteilhaft, da der Matchalgorithmus bisher keinen Unterschied zwischen syntaktischer Gleichheit und semantischer Gleichheit macht.}.
 Jeder neu gebundene Parameter bekommt als Index die Anzahl der weiter außen bzw. in der selben Abstraktion vor ihm gebundenen Parameter. Zur Veranschaulichung wird hier der Index im Tiefsatz mitgeschrieben. Wichtig ist hervorzuheben, dass die hier nach wie vor dargestellten Namen ausschließlich der Übersichtlichkeit dienen und in der Umsetzung nicht gespeichert sind.
 Als Beispiel dient $\lambda x_0 y_1 .\lambda z_2 .x_0 + y_1 + z_2$. Das Zeichen $x$ wird in der äußersten Abstraktion zuerst gebunden, hat also keine Vorgänger und dementsprechend Index $0$. In der selben Abstraktion wird als zweiter Parameter weiter $y$ gebunden. Als Nachfolger von $x$ wird $y$ Index $1$ zugewiesen. Die Bindung von $z$ liegt innerhalb der Abbildungsvorschrift des äußeren Lambdas, $x$ und $y$ können also referenziert werden. Dementsprechend hat $z$ zwei Vorgänger und Index $2$. 
 
 Die Auswertung der Funktionsanwendung einer Lambdafunktion $f$ entspricht der $\beta$-Reduktion (von Church \cite{ChurchLambda36} als \textit{operation II} bezeichnet). Parameter von $f$ werden dafür durch die übergebenen Argumente ersetzt. Enthält die Definition von $f$ selbst weitere Lambdaabstraktionen, so werden die Indices derer Parameter um die Stelligkeit von $f$ erniedrigt.
 Der Ausdruck $(\lambda x_0 y_1 .\lambda z_2 .x_0 + y_1 + z_2)(3, 6)$ wird damit zum Ausdruck $\lambda z_0 .3 + 6 + z_0$ ausgewertet.
 
 Die gewählte Indizierung hat ein Problem, welches die De Bruijn Indizierung nicht besitzt. Der Index eines Lambdaparameters ist abhängig vom Kontext der bindenden Abstraktion. Ändert sich dieser Kontext, stimmt die bisherige Indizierung möglicherweise nicht mehr:
 Enthält ein Argument $a$ der Funktionsanwendung einer Lambdafunktion $f$ selbst eine Lambdafunktion $g$, so reicht es für die Auswertung von $f$ mit bisher diskutierten Konzepten nicht aus, den entsprechenden Lambdaparameter von $f$ einfach durch $a$ zu ersetzen. Sollte diese Ersetzung innerhalb einer Lambdaabstraktion $f'$ stattfinden, müssen alle Lambdaparameter von $g$ im Index um die Anzahl der weiter außen gebundenen Parameter erhöht werden. Als Beispiel ist $a = g = \lambda x_0 .x_0$ die Identität, welche der Funktion $f = \lambda x_0 .\lambda y_1 .x_0(y_1)$ übergeben wird. Teil der Definition von $f$ ist $f' = \lambda y_1 .x_0(y_1)$.
 $$(\lambda x_0 .\lambda y_1 .x_0(y_1))(\lambda x_0 .x_0)$$
 
 An dieser Stelle wird zudem eine alternative Notation eingeführt, die nur Information benutzt, die der Implementierung tatsächlich bekannt ist. Ehrlicher ist die Darstellung einer Lambdaabstraktion mit $n$ Parametern als $\lambda [n] .\textit{<Definition>}$. Mit den Parametern geschrieben als Prozentzeichen gefolgt von ihrem Index, ist der problematische Ausdruck geschrieben als
 
 $$(\lambda [1] .\lambda [1] .\%0(\%1))(\lambda [1] .\%0).$$
 Die naive Ersetzung von $x_0$ in $f$ durch $g$ würde im folgenden Ausdruck resultieren.
 $$\lambda y_0 .(\lambda x_0 .x_0)(y_0)$$
 Ohne Namen ist jetzt klar, dass in der Abbildungsvorschrift von $g$ nun fälschlicherweise auf den Parameter von $f'$ abgebildet wird.
 $$\lambda [1] .(\lambda [1] .\%0)(\%0)$$
 Es gibt verschiedene Möglichkeiten, den Fehler zu beheben. Eine einfache Lösung ist, Indices von eingesetzten Argumenten in der Auswertung einer Lambdafunktion entsprechend anzupassen. Konsequenz wäre aber, dass die Komplexität der Auswertung von der Größe der Argumente abhängig ist. Ein weiterer Nachteil ist, dass veränderte Argumente kopiert werden müssen. Das macht \textit{lazy evaluation} \cite{EvalStrategien}, also die Idee, jede Funktionsanwendung höchstens einmal auswerten zu müssen, unmöglich.
 
 Eine Alternative ist die Unterscheidung zwischen sogenannten \Emph{\glspl{transparent}} Lambdas und \Emph{nicht-transparenten} Lambdas, zweitere dargestellt durch umschließende geschweifte Klammern: $\{\lambda \textit{<Parameter>}.\textit{<Definition>}\}$ bzw. $\{\lambda [n].\textit{<Definition>}\}$. Kommt ein transparentes Lambda $f'$ in der Definition eines Lambdas $f$ vor, wird bei der Auswertung von $f$ auch in $f'$ nach Lambdaparametern gesucht und diese ersetzt bzw. deren Index erniedrigt. Transparente Lambdas verhalten sich damit nicht anders als die Lambdas bisher. Ist $f'$ allerdings nicht-transparent, lässt die Auswertung von $f$ die Definition von $f'$ unberührt. 
 Mit zwei weiteren Bedingungen wird die Überprüfung von Argumenten bei der Auswertung Lambdas dann obsolet: 
 Zum einen darf ein \Emph{außenliegendes} Lambda $f$ nicht transparent sein. Ein Lambda ist außenliegend, wenn es nicht Teil der Definition eines weiteren Lambdas ist, also zu seinen Ahnen keine Lambdaabstraktionen gehören. Zum anderen darf die Funktionsanwendung eines Lambdas nur ausgewertet werden, wenn das Lambda außenliegend ist. Damit wird garantiert, dass während der Auswertung des Lambdas $f$ kein Argument $a$ direkt transparente Lambdas enthält, höchstens als Teil $g'$ (im Beispiel nicht enthalten) eines nicht-transparenten Lambdas $g$.

Im bereits behandelten Problemfall sind $f$ und $g$ damit nicht-transparent. Nur $f'$ ist zu Beginn transparent. Nach Auswertung von $f$ ist $f'$ dann jedoch ebenfalls außenliegend.
\begin{align*}
    ~           &~\{\lambda x_0 .\lambda y_1 .x_0(y_1)\}(\{\lambda x_0 .x_0\}) \\
    \rightarrow &~\{\lambda y_0 .\{\lambda x_0 .x_0\}(y_0)\}\\
\end{align*}
Alternativ ohne Namen:
\begin{align*}
    ~           &~\{\lambda [1] .\lambda [1] .\%0(\%1)\}(\{\lambda [1] .\%0\}) \\
    \rightarrow &~\{\lambda [1] .(\{\lambda [1] .\%0\})(\%0)\}\\
\end{align*}
Bemerkenswert ist, dass mit den soeben formulierten Bedingungen der Ausdruck nicht weiter transformiert werden darf. Das liegt daran, dass die Funktionsanwendung von $g$ selbst noch vom Lambda $f'$ umschlossen ist. Es ist also nicht ausgeschlossen, dass Argumente der Funktionsanwendung von $g$ (hier nur $\%0$) direkt transparente Lambdas enthalten\footnote{Eng verwandt ist der Grund, warum auch bei der Verwendung von De Bruijn Indices ohne weiteres nur die äußerste Funktionsanwendung abgebildet werden darf. In dem Fall könnte sich sonst die Anzahl der Abstraktionen zwischen einer Variable in einem Argument und ihrer eigenen Abstraktion ändern. Der alte De Bruijn Index würde die Variable dann der falschen Abstraktion zuordnen.}.




%.........................................................................
%.........................................................................
%.........................................................................
\section{Mustervariablen} \label{subsecMustervariablen}
In der Umsetzung wird zwischen drei Arten von Mustervariablen unterschieden. Die Sonderform der Multi-Mustervariable ist bereits aus Kapitel \ref{subsecMulti} bekannt, die Wert-Mustervariable ist allerdings neu. Als drittes ist die normale Mustervariable nach wie vor vorhanden. Wert-Mustervariable und normale Mustervariable können zudem durch Bedingungen eingeschränkt werden.

\subsection{Wert-Mustervariable} \label{subsubsecWertMustervariable}
Nach Definition \ref{defMatch} ist das Match $v_p$ für ein Paar $(p, t)$ aus Muster $p$ und Literal $t$ dann gültig, wenn $\Const{lit}(p, v_p) = t$ gilt. In Kapitel \ref{secPattermatching} nicht diskutiert wurde die Möglichkeit, Zahlen mit Rechenausdrücken zu matchen. Ein Muster $p = (\texttt{prod}, 2, \mathbf k)$ würde für das Literal $t = 12$ etwa ein Match $v_p$ mit $v_p~\mathbf k = 6$ besitzen. Um die Matchsuche nicht zu kompliziert zu gestalten, besitzt die Umsetzung zwei Einschränkungen. Zum einen ist eine solche Dekonstruktion des Musters zu einem Wert nur dann möglich, wenn das entsprechende Teilmuster exakt eine Instanz $w$ einer Wert-Mustervariable enthält. Zum anderen werden nur bijektive Funktionen\footnote{bzw. sonst Mehrdeutigkeiten ignoriert} dekonstruiert, wie im Beispiel die Multiplikation mit $2$. Die Umsetzung ist damit eine Verallgemeinerung von n+k-Mustern aus Haskell \cite{nPlusK}.


Vor einem Matchversuch muss ein Muster mit Wert-Mustervariablen transformiert werden. Ziel der Transformation ist, dass für den Matchalgorithmus direkt klar ist, ab wo das Muster einen Wert repräsentieren soll. Der Teilbaum des Musters, der eine Wert-Mustervariable $w$ enthält und als ganzes einen Wert matchen soll, ist idealerweise also direkt gekennzeichnet. In der Umsetzung ist das realisiert, indem eine Wert-Mustervariable im zu matchenden Muster kein Blatt darstellt, sondern einen Teilbaum markiert. Dieser entspricht nicht der ursprünglichen Umgebung um die Wert-Mustervariable, sondern derer Inversen. 

\begin{figure}
\begin{unbreakable}\begin{verbatim}
value_match__(_i, _dom, _inv) + _a + cs... | _a :complex 
    = value_match__(_i, _dom, \x ._inv(x - _a)) + cs...
        
value_match__(_i, _dom, _inv) * _a * cs... | _a :complex 
    = value_match__(_i, _dom, \x ._inv(x / _a)) * cs...
        
value_match__(_i, _dom, _inv) ^ 2
    = value_match__(_i, _dom, \x ._inv(sqrt(x)))
        
sqrt(value_match__(_i, _dom, _inv))
    = value_match__(_i, _dom, \x ._inv(x^2))
\end{verbatim}\end{unbreakable}
\caption{Transformationsregeln für Muster mit Wert-Mustervariable}
\label{figWertMusterBau}
\end{figure}

Die Transformation in diese Form erfolgt über Anwendung von Ersetzungsregeln. Die Wert-Mustervariable wird dazu temporär als Funktionsanwendung des Symbols \verb|value_match__| gespeichert. Die Regeln sind jeweils zweizeilig in Abbildung \ref{figWertMusterBau} aufgeführt. Das Funktionssymbol erwartet drei Argumente, hier die Mustervariablen \verb|_i| für den Identifikationsindex, \verb|_dom| für den erlauben Raum (kurz für \textit{domain}) und \verb|_inv| für den Teilterm, der für Inverse des bereits umgewandelten Teils der Umgebung steht. Zu Beginn steht die Identitätsfunktion an Stelle von \verb|_inv|.
Die finale Repräsentation einer Wert-Mustervariablen entspricht in den gespeicherten Informationen fast exakt der Zwischenform als Funktionsanwendung von \verb|value_match__|. 
Ergänzt wird einzig, ob die jeweilige Instanz bindend oder gebunden ist. Die genaue Form von \verb|_inv| ändert sich zudem auch leicht, die Idee allerdings nicht. 

Im Match der Wert-Mustervariablen $w$ mit einer komplexen Zahl $z$ als Literal wird der in Abbildung \ref{figWertMusterBau} \verb|_inv| genannte Teilbaum genutzt, um den Wert, den die Wert-Mustervariable an ihrem ursprünglichen Ort im Muster für ein Match besitzen müsste, zu bestimmen. Berechnet werden kann dieser als Anwendung von \verb|_inv| auf das Literal. 

$$w = \verb|inv(|z\verb|)|$$

Je nachdem, ob $w$ eine bindende oder eine gebundene Instanz ist, wird der berechnete Wert im Matchzustand\footnote{siehe Abschnitt \ref{subsubsecMatchalgoCpp}} gespeichert oder mit dem bereits gespeicherten Wert verglichen.

\begin{beispiel}
Das Muster $p =$ \verb~cos(2 $k pi) | $k :int~ mit der Wert-Mustervariable $w =$ \verb|$k| wird in der Zwischenrepräsentation dargestellt als 
\begin{unbreakable}\begin{verbatim}
cos(2 value_match__(0, int, \y .y) pi). 
\end{verbatim}\end{unbreakable}
Die zweite Regel aus Abbildung \ref{figWertMusterBau} lässt sich mit $v_p$ \verb|_a| = \verb|2| auf den gegebenen Term anwenden. Die Normalform von $p$ ist das Ergebnis der Regelanwendung:
\begin{unbreakable}\begin{verbatim}
cos(value_match__(0, int, \x .(\y .y)(x / 2)) pi)
\end{verbatim}\end{unbreakable}
Nach Umwandlung der Funktionsanwendung von \verb|value_match__| in die interne Darstellung, genannt $w'$, hat das finale Muster die Form $p' =$ \verb|cos(|$w'$\verb| pi)|. 
Die interne Darstellung vereinfacht zudem den Ausdruck der Inversen. Ein Lambda näher an dieser Form ist \verb|(\x .x / 2)|.

Das Literal \verb|cos(8 pi)| kann mit $p'$ gematcht werden. Dazu muss \verb|8| mit $w'$ matchen. Das funktioniert, denn \verb|(\x .x / 2)(8)| wird zu $v_p~w =$ \verb|4| ausgewertet. Damit erfüllt das Match die für $w$ zu Beginn geforderte Bedingung der ganzen Zahl. 
\end{beispiel}

\subsubsection{Starke Ordnung}
In Kapitel \ref{subsecCMuster} wurden Wert-Mustervariablen ausgeschlossen, da sie die starke Ordnung vieler Muster zueinander zerstören. In der hier beschriebenen Umsetzung ist das allerdings nicht der Fall. Nach außen verhält sich eine Wert-Mustervariable in matchbereiter Konfiguration exakt wie eine normale Mustervariable, die ausschließlich bestimmte Teilmengen der Komplexen Zahlen matchen kann. Die Frage, welche Funktionsanwendungen eines Musters auch Konstantensymbole matchen können, stellt sich damit nicht mehr während der Ausführung des Matchalgorithmus. Die entsprechenden Teile des Musters wurden bereits vorab erkannt und mit den Regeln aus Abbildung \ref{figWertMusterBau} so transformiert, dass die Wert-Mustervariable direkt den gesamten Teilbaum repräsentiert.

Nachteil dieser Vorgehensweise ist, dass an manchen Stellen mehrere fast identische Muster benötigt werden, da Wert-Mustervariablen jetzt ausschließlich Werte erkennen, nicht mehr die ursprünglichen Teilbäume. 


\subsection{Bedingungen} \label{subsubsecBedingungen}

Muster können durch Bedingungen an normale Mustervariablen in möglichen Matches weiter eingeschränkt werden.
Diese Bedingungen übernehmen teilweise eine ähnliche Rolle wie die Wert-Mustervariablen\footnote{siehe Abschnitt \ref{subsubsecCos}}, sind dabei aber etwas flexibler. 


\subsubsection{Mögliche Ausdrücke}
Bedingungen, die nicht mit Wert-Mustervariablen dargestellt werden könnten, nutzen primär die Funktionssymbole \verb|contains|, \verb|neq| und \verb|of_type__|. Ersteres ist binär und prüft, ob das erste Argument Teilbaum des zweiten Argumentes ist\footnote{siehe Abschnitt \ref{subsubsecDiff}}. Zweiteres (normal in Infixform \verb|!=| geschrieben) ist ebenfalls binär und prüft, ob zwei Teilbäume ungleich sind. Beide dürfen dabei ausschließlich direkt Mustervariablen als Argumente übergeben bekommen. 

Genauso ist das Symbol \verb|of_type__| binär und wird normal nicht ausgeschrieben hingeschrieben, sondern tritt als Infixoperator \verb|:| auf. Die Bedeutung variiert dann nach dem rechten Argument. Ist dies ein Knotentyp, etwa \verb|complex| oder \verb|f_app|, prüft \verb|of_type__|, ob das linke Argument von diesem Typ ist. Eine spezifischere Variante der Bedingung \verb|_x :f_app| ist {\verb|_x :|$f$}, mit einem Symbol $f$. In dem Fall wird geprüft, ob die linke Seite eine Funktionsanwendung von $f$ ist. Beispielsweise muss mit der Bedingung \verb|_x :sum| die Mustervariable \verb|_x| mit einer Summe, also einer Funktionsanwendung des Symbols \verb|sum|, gematcht sein, damit das Match gültig ist.
Der dritte Spezialfall tritt auf, wenn die rechte Seite eine fest definierte Teilmenge der Komplexen Zahlen ist, etwa \verb|_x :int|. Die linke Seite muss dann nicht direkt eine Mustervariable sein, sondern lediglich zu einer Komplexen Zahl ausgewertet werden können\footnote{siehe Abschnitt \ref{subsubsecCos}}.

\subsubsection{Umsetzung}
Eine Bedingung, die mehrere Mustervariablen enthält, wird der Mustervariablen hinzugefügt, deren bindende Instanz auf der linken Regelseite als letztes vorkommt. Ist eine solche Mustervariable dann von mehreren Bedingungen abhängig, werden diese als Argumente des variadischen Funktionssymbols \verb|and| zusammengefasst. Die Überprüfung einer Bedingung wird durchgeführt, wenn Algorithmus $\Const{findMatch}$ die entsprechende Mustervariableninstanz als Argument erhält. 





%.........................................................................
%.........................................................................
%.........................................................................
\section{Datenstruktur}
Die Knoten des Termbaums liegen in einem Array, dem sogenannten \verb|Store|. Während eine Komplexe Zahl oder ein Lambdaparameter immer ein Arrayelement besetzen, kann die Funktionsanwendung auch mehrere direkt hintereinanderliegende Arrayelemente nutzen, je nachdem, wie viele Argumente referenziert werden müssen. Referenziert wird ein Knoten aus einem Paar aus Arrayindex und Knotentyp, beide dargestellt als natürliche Zahl. Dieses Paar wird \verb|NodeIndex| genannt. Der Knotentyp wird als \verb|NodeType| bezeichnet und kann die in Tabelle \ref{tabNodeType} gelisteten 12 verschiedene Werte annehmen, eng verwandt mit Definition \ref{defKnotentypenMathe}.

\begin{figure}
    \centering
    \begin{tabular}{l l}
        \hline
        Wert & repräsentiert\\
        \hline \hline
        0 & $\Sigma^+$\\
        \hline
        1 & Komplexe Fließkommazahl\footnote{Die Nutzung von Fließkommazahlen ist für Computeralgebra nur bedingt geeignet, erlaubt aber die Verwendung der im C\texttt{++} Standard geforderten Rechenoperationen für Komplexe Zahlen. Über Auslesen der entsprechenden CPU-Flags kann dennoch garantiert werden, dass ausschließlich exakte Vereinfachungen durchgeführt werden.}\\
        \hline
        2 & $\Lambda$\\
        \hline
        3 & $V$\\
        \hline
        4 & Funktionsanwendung in einem Literal\\
        \hline
        5 & Funktionsanwendung in einem Muster\\
        \hline
        6 & \shortstack[l]{Hilfstyp, aktuell genutzt in der Transformation eines Musters \\ mit Wert-Mustervariablen}\\
        \hline
        7 & \shortstack[l]{bindende Instanz einer Mustervariable $\mathbf x \in X$ an die im Muster \\ Bedingungen geknüpft sind}\\
        \hline
        8 & bindende Instanz einer Mustervariable $\mathbf x \in X$ ohne weitere Bedingungen\\
        \hline
        9 & gebundene Instanz einer Mustervariable $\mathbf x \in X$\\
        \hline
        10 & $X^*$\\
        \hline
        11 & $W$\\
        \hline
    \end{tabular}
    \caption{Werte von \texttt{NodeType}}
    \label{tabNodeType}
\end{figure}

Manche der hier aufgezählten Knoten müssen neben ihrem Typen nur eine einzige natürliche Zahl kennen. Bereits diskutiert wurde das für Knoten von Typ $3$, den Lambdaparametern. Für einen Knoten dieser Art ist es nicht notwendig, die Information als eigenes Arrayelement des \verb|Store| zu speichern; der Index des Paares aus Index und Typ von \verb|NodeType| enthält direkt den erforderlichen Wert. Damit werden die entsprechenden Argumente ohne Indirektion direkt in einer Funktionsanwendung gespeichert. Knoten dieser Art sind Typ 0, 3, 6, 8 und 9. Für Symbole aus $\Sigma^+$ wird nicht der Name selbst gespeichert, sondern der Index in einem zentralen Namensspeicher\footnote{Nicht optimal ist damit, dass die Ordnung zweier Symbole aus $\Sigma^+$ zueinander von der Reihenfolge der Auflistung im Namensspeicher und damit von der Eingabereihenfolge abhängen, was aber nur ästhetische Nachteile birgt.}. Der Zugriff auf den Namensspeicher wird so auf die Eingabe und Ausgabe eines Terms beschränkt.


Alle im \verb|Store| mögliche Belegungen eines Feldes sind der \verb|union| \verb|TermNode| aus Quelltext \ref{codeTermNode} zusammengefasst. Der Typ \verb|Complex| ist dabei nur ein Alias für \verb|std::complex<double>|. Interessant ist der Typ \verb|FApp|, welcher die Funktionsanwendung repräsentiert. Intern ist dieser Typ erneut polymorph, da das erste Arrayfeld einer Funktionsanwendung nicht nur die ersten \verb|NodeIndex| Referenzen auf Funktion und Argumente enthält, sondern auch die Information, wie viele Arrayfelder von der Funktionsanwendung besetzt sind und wie viele Argumente insgesamt gehalten werden. Folgende Felder im \verb|Store| halten ausschließlich weitere Argumente.


\begin{listing}
\footnotesize
\begin{minted}[xleftmargin=2em, linenos, breaklines]{cpp}
union TermNode 
{
    //nodes valid everywhere:
    Complex complex;
    FApp f_app;
    Lambda lambda;
    
    //nodes only expected in a pattern:
    RestrictedSingleMatch single_match;
    MultiMatch multi_match; //only expected in right hand side
    ValueMatch value_match;
    FAppInfo f_app_info; //metadata for f_app in pattern (directly preceeding)
};
\end{minted}
\caption{mögliche Einträge eines Feldes im Speicher}
\label{codeTermNode}
\end{listing}



\begin{beispiel} \label{bspREPLliteral}
Das Literal \verb|tup(f(a, b)(c), 1, 2, 3)| wird in der folgenden Debugausgabe genutzt, um den Speicheraufbau zu veranschaulichen.
\begin{unbreakable}
\begin{verbatim}
  head at index: 5
   0 | application:     { 121,  92,  93 }    f(a, b)
   1 | application:     {   0,  94 }         f(a, b)(c)
   2 | value      :                          1
   3 | value      :                          2
   4 | value      :                          3
   5 | application:     {  78,   1,   2,     tup(f(a, b)(c), 1, 2, 3)
   6 |   ...           3,   4 }
\end{verbatim}
\end{unbreakable}
Die linke Spalte gibt den Arrayindex an. Nach der Art des gespeicherten Knotens folgt dann für Funktionsanwendungen die Auflistung der Funktion und Argumente. Ganz rechts ist der Teilbaum beginnend an dem entsprechenden Arrayindex angegeben. Bemerkenswert ist, dass die Symbole \verb|f|, \verb|tup|, \verb|a|, \verb|b| und \verb|c| als solche nicht im Array gespeichert sind. Die Funktionsanwendung von \verb|f| gespeichert an Index 0 verrät, dass das Programm vor dem Parsen von Symbol \verb|f| bereits 121 andere unbekannte Symbole eingelesen hat. Analog ist \verb|a| als Index 92, \verb|b| als Index 93 und \verb|c| als Index 94 gespeichert. 
Interessant ist weiter, dass die Funktionsanwendung des Symbols \verb|tup| beginnend an Arrayindex 5 auch das darauffolgende Arrayelement belegt. Bis auf den Index von \verb|tup|, sind die restlichen Indices dieser Funktionsanwendung Arraypositionen. 
\end{beispiel}


\begin{beispiel} \label{bspREPLlambda}
Die in Abschnitt \ref{subsecLambdafunktionen} genutzte Notation für Lambdas mit namenlosen Lambdaparametern wird auch in der Umsetzung zur Darstellung von Lambdafunktionen genutzt. Als Beispiel wird die Speichernutzung des Literals \verb|(\f x .f(x, x))(sum, 3)| gezeigt.
\begin{unbreakable}\begin{verbatim}
  head at index: 3
   0 | application:     {   0,   1,   1 }    %0(%1, %1)
   1 | lambda     :                          {\[2].%0(%1, %1)}
   2 | value      :                          3
   3 | application:     {   1,  81,   2 }    {\[2].%0(%1, %1)}(sum, 3)
\end{verbatim}\end{unbreakable}
Nach Auswertung von $\Const{normalize}$ ändert sich die Speicherbelegung.
\begin{unbreakable}\begin{verbatim}
  head at index: 0
   0 | value      :                          6
   1 | -----free slot-----
   2 | -----free slot-----
   3 | -----free slot-----
   4 | -----free slot-----
\end{verbatim}\end{unbreakable}
Zuerst wurden die Argumente \verb|sum| und \verb|3| in eine Kopie der Lambdadefinition eingesetzt\footnote{Deswegen sind in der zweiten Version fünf, statt der ursprünglichen vier Slots zu sehen.}, dann wurde die Funktionsanwendung von \verb|sum| zur Komplexen Zahl \verb|6| ausgewertet. Diese kann in einem einzelnen Arrayelement gespeichert werden, der restliche Platz ist jetzt ungenutzt.
\end{beispiel}





%.........................................................................
%.........................................................................
%.........................................................................
\section{Algorithmen} \label{subsecCppAlgos}

Die beschriebene Datenstruktur wird in den meisten Fällen rekursiv abgelaufen. Der einzelne \verb|NodeIndex| bietet aber nicht genug Information, um zu wissen, wo der referenzierte Knoten gespeichert ist. Das Array des \verb|Store| muss adressierbar sein. Für diesen Zweck gibt es Hilfstypen, die eine Referenz auf den \verb|Store| bzw. das unterliegende Array mit dem \verb|NodeIndex| bündeln. Die mutierbare Variante wird als \verb|MutRef| bezeichnet. Soll nur lesen des Terms erlaubt sein, gibt es die Hilfstypen \verb|Ref| und \verb|UnsaveRef|. 

\begin{listing}
\footnotesize
\begin{minted}[xleftmargin=2em, linenos, breaklines]{cpp}
void free_tree(const MutRef ref)
{
    if (!is_stored_node(ref.type) || ref.store->decr_at(ref.index) != 0) { 
        return; 
    }
    switch (ref.type) {
    case NodeType(Literal::lambda):
        free_tree(ref.at(ref->lambda.definition));
        break;
    case NodeType(Literal::f_app):
        for (const NodeIndex subtree : ref) {
            free_tree(ref.at(subtree));
        }
        FApp::free(*ref.store, ref.index);
        return;
    case NodeType(SingleMatch::restricted_):
        free_tree(ref.at(ref->single_match.condition));
        break;
    case NodeType(SpecialMatch::value):
        free_tree(ref.at(ref->value_match.inverse));
        break;
    }
    ref.store->free_one(ref.index);
} //free_tree
\end{minted}
\caption{Speicherfreigabe eines Teilterms}
\label{codeFreeTree}
\end{listing}

Illustriert wird die Vorgehensweise des Ablaufens des Terms als Baum mit polymorphen Knoten anhand der Funktion \verb|free_tree|, dargestellt als Quelltext \ref{codeFreeTree}, welche im \verb|Store| die von dem übergebenden Teilbaum \verb|ref| belegten Arrayfelder freigibt. Diese Freigabe ist aber nur möglich, wenn in Zeile 3 festgestellt wird, dass zu dem Term auch Arrayelemente im \verb|Store| gehören und dass diese von nirgendwo sonst referenziert werden,
 Die Felder \verb|ref.type| und \verb|ref.index| von \verb|MutRef| sind als Daten von \verb|NodeIndex| zu erkennen. Die Methode \verb|ref.at(|$x$\verb|)| konstruiert eine Referenz zu einem neuen Teilterm $x$, übergeben als \verb|NodeIndex|.
Die Werte, die die einzelnen \verb|case|-Statements differenzieren, sind die Zahlen aus Tabelle \ref{tabNodeType}, jedoch zur Kompilierzeit berechnet aus korrespondierenden \verb|enum|-Werten.

\subsection{Eingebaute Auswertung und Normalisierung} \label{subsubsecAuswertungNormalCpp}

Die \glqq natürliche\grqq{} Auswertung der Funktionsanwendungen eingebauter Funktionssymbole, etwa \verb|sum|, \verb|prod|, \verb|sin|, etc. zu Komplexen Zahlen ist in der Umsetzung fest eingebaut und ausschließlich als Teil des ebenfalls fest eingebauten $\Const{normalize}$ Algorithmus vorhanden. Dieser unterscheidet sich insofern von Kapitel \ref{secErsteNormalform}, als dass alle beschriebenen Normalisierungsschritte in der nicht rekursiven Funktion \verb|normalize::outermost| implementiert sind, welche ausschließlich eine außenliegende Funktionsanwendung ändert. Das erlaubt, in der Ersetzung eines Teilterms durch ein Muster, ausschließlich die neuen Teile des Literals auf mögliche Normalisierungen zu prüfen.

\begin{listing}
\footnotesize
\begin{minted}[xleftmargin=2em, linenos, breaklines]{cpp}
NodeIndex normalize::recursive(const MutRef ref, const Options options)
{
    assert(ref.type != PatternFApp{});
    if (ref.type == Literal::f_app) {
        auto iter = begin(ref);
        *iter = normalize::recursive(ref.at(*iter), options);
        if (nv::is_lazy(*iter)) [[unlikely]] {
            const NodeIndex result = normalize::outermost(ref, options).res;
            return normalize::recursive(ref.at(result), options);
        }
        else {
            for (++iter; !iter.at_end(); ++iter) {
                *iter = normalize::recursive(ref.at(*iter), options);
            }
        }
    }
    return normalize::outermost(ref, options).res;
} //recursive
\end{minted}
\caption{rekursive Normalisierung eines Literals}
\label{codeNormalizeRecursive}
\end{listing}

Erst die Funktion \verb|normalize::recursive|, abgebildet als Quelltext \ref{codeNormalizeRecursive}, implementiert die Auswertungsstrategie für den Gesamtterm: Zuerst wird in Zeile 6 das Funktionssymbol berechnet, was in der aktuellen Funktionsanwendung angewendet wird. Möglich ist, dass ein Funktionssymbol faul ist\footnote{Das ist aktuell ausschließlich für \texttt{true} und \texttt{false} als binäre Funktionen der Fall: \texttt{true} bildet auf das erste Argument ab, \texttt{false} auf das zweite.}, also vor seinen Argumenten normalisiert wird. 
Sonst erfolgt in Zeile 13 der Rekursionsaufruf für jedes Argument, bevor zum Schluss in Zeile 17 der gesamte Term normalisiert wird.



\subsection{Matchalgorithmen} \label{subsubsecMatchalgoCpp}

Die große Lücke bei der Diskussion des Matchalgorithmus in Kapitel \ref{secPattermatching} ist die Datenstruktur, die nicht nur das finale Match enthalten muss, sondern auch, welches Musterargument gerade mit welchem Literal gematcht ist - und das für jede Funktionsanwendung des Musters. Diese Datenstruktur wird als C\texttt{++} Referenz\footnote{äquivalent zu einem Zeiger, nur bereits dereferenziert} mit dem Namen \verb|match_state| übergeben, wie in Quelltext \ref{codeRematchDecl} gezeigt. 

\begin{listing}
\footnotesize
\begin{minted}[xleftmargin=2em, linenos, breaklines]{cpp}
bool find_match(const UnsaveRef pn_ref, const UnsaveRef ref, State& match_state);

bool rematch(const UnsaveRef pn_ref, const UnsaveRef ref, State& match_state);

bool find_identic(const UnsaveRef pn_ref, const UnsaveRef hay_ref, State& match_state, const bool find_rematch);

bool find_permutation(const UnsaveRef pn_ref, const UnsaveRef hay_ref, State& match_state, const bool find_rematch);

bool find_dilation(const UnsaveRef pn_ref, const UnsaveRef hay_ref, State& match_state, const bool find_rematch);
\end{minted}
\caption{Funktionsdelarationen der Algorithmen \ref{findMatch}, \ref{rematch}, \ref{findIdentic}, \ref{findPermutation} und \ref{findDilation}}
\label{codeRematchDecl}
\end{listing}

Der Typ \verb|State| enthält primär drei Arrays. Im Array \verb|.single_vars| sind die Referenzen der Teilterme des Literals, mit dem die bindenden Instanzen der normalen Mustervariablen aktuell assoziiert sind, als \verb|NodeIndex| gespeichert.
Im Array \verb|.value_vars| ist für jede Wert-Mustervariable der aktuell assoziierte Wert gespeichert. Diese beiden Arrays implementieren damit fast exakt das Match $v_p$. Die Indices der Mustervariablen werden in den Arrays auf die entsprechend assoziierten Literale abgebildet.
Nicht ausschließlich als Teil $v_p$ zu verstehen, ist der Teil von \verb|match::State|, der die Matchkonfiguration jeder Funktionsanwendung des Musters mit kommutativem Funktionssymbol oder mit Multi-Mustervariablen unter den Argumenten festhält. Das Array \verb|.f_app_entries| hält diese Konfigurationen mit einem Element für jede darauf zurückgreifende Funktionsanwendung. Ein solches Element besteht selbst aus einem Array mit einem Eintrag für jedes Argument der Funktionsanwendung. Wenn Musterargument $p_i$ aktuell mit Argument $t_k$ des Literals gematcht ist, steht in diesem Array an Index $i$ der Eintrag $k$. Eine sekundäre Funktion besitzt \verb|.f_app_entries| für Multi-Mustervariablen. Die Argumente des Literals, die einer entsprechenden Mustervariablen zugeordnet werden, können hieraus rekonstruiert werden, da die Multi-Mustervariablen genau die Stellen besetzen, die mit keinem normalen Argument gematcht sind. Das erlaubt der Implementierung, die Multi-Mustervariablen auf der linken Seite eines Musters so zu nutzen, wie im Pseudocode angedeutet, also als einfache Logikwerte in einem Array bei jeder Funktionsanwendung. 




%.........................................................................
%.........................................................................
%.........................................................................
\section{Anwendung} \label{subsecCppAnwendung}

\subsection{Ableiten} \label{subsubsecDiff}

Wenn auch Ableitungsregeln nicht die Möglichkeiten des assoziativen und kommutativen Matches ausnutzen, bieten sie doch eine gute erste Übersicht der Nutzung eines Termersetzungssystems.

\begin{unbreakable}\begin{verbatim}
diff(_x, _x)                     = 1
diff(_a, _x) | !contains(_a, _x) = 0
diff(_g^_h, _x) = (diff(_h, _x) ln(_g) + _h diff(_g, _x) / _g) _g^_h
diff(_a, _x) | _a :sum = map(sum, \f .diff(f, _x), _a)
diff(_u vs..., _x) = diff(_u, _x) vs... + _u diff(prod(vs...), _x)
diff(_f(_y), _x) = diff(_y, _x) fdiff(_f)(_y)

fdiff(\x ._y) = \x .diff(_y, x)
fdiff(sin)     = cos
fdiff(cos)     = \x .-sin(x)
fdiff(exp)     = exp
fdiff(ln)      = \x .x^(-1)
fdiff(tan)     = \x .cos(x)^(-2)
...
\end{verbatim}\end{unbreakable}

Die linken Seiten sind entweder Funktionsanwendungen des binären Funktionssymbols \verb|diff| oder des unären Funktionssymbols \verb|fdiff|. Während \verb|diff| einen beliebigen Term als erstes Argument erwartet, gefolgt von dem Symbol, nach dem abgeleitet werden soll, leitet \verb|fdiff| unäre Funktionen ab. Das vereinfacht die Syntax zur Darstellung der Kettenregel, welche als letzte Regel für \verb|diff|  vor der Leerzeile umgesetzt ist. Interessant ist bei dem entsprechenden Muster \verb|diff(_f(_y), _x)|, dass die Funktion, deren Anwendung abgeleitet wird, repräsentiert durch die Mustervariable \verb|_f|, selbst eine Unbekannte ist. Die rechte Seite \verb|diff(_y, _x) fdiff(_f)(_y)| implementiert dann das \glqq innere mal äußere Ableitung\grqq{}-Muster. Da \verb|fdiff(_f)| eine Funktion zurückgibt, kann auf diese Funktion das Argument \verb|_y| angewendet werden.

Im folgenden wird die rechte Seite der vierten Regel diskutiert.
\begin{verbatim}
diff(_a, _x) | _a :sum = map(sum, \f .diff(f, _x), _a)
\end{verbatim}
Das Funktionssymbol \verb|map| hat eine fest in $\Const{normalize}$ eingebaute Auswertung: Sollte das dritte Argument eine Funktionsanwendung des ersten Argumentes $g$ sein, wird wieder eine Funktionsanwendung von $g$ zurückgegeben, allerdings mit dem zweiten Argument von \verb|map| angewendet auf jedes Argument von $g$. In Ersetzungsregeln geschrieben sähe die Abbildungsvorschrift von \verb|map| beispielsweise wie folgt aus.
\begin{unbreakable}\begin{verbatim}
map(_g, _f, _g(xs...)) 
    = map_helper(_g(), _g(xs...), _f)

map_helper(_g(xs...), _g(_y, ys...), _f) 
    = map_helper(_g(xs..., _f(_y)), _g(ys...), _f)

map_helper(_g_app, _g(), _f) 
    = _g_app
\end{verbatim}\end{unbreakable}

In der konkreten Anwendung im Muster wird also die Ableitung einer Summe umgeschrieben als die Summe der Ableitungen der Argumente. Das Muster
\begin{verbatim}
diff(_u + vs..., _x) = diff(_u, _x) + diff(sum(vs...), _x)
\end{verbatim}
hätte in wiederholter Anwendung den selben Effekt. Die genutzte Version benötigt allerdings nur eine einzige Ersetzung\footnote{sofern \texttt{map} in $\Const{normalize}$ ausgewertet wird} für eine Summe mit beliebig vielen Argumenten.

\begin{beispiel}
Angewendet auf das Literal \verb|diff(sin(pi t) + 3, t)| erzeugen die Ableitungsregeln folgende Zwischenergebnisse bzw. folgende Normalform (Leerzeichen sind zur verbesserten Lesbarkeit ergänzt).
\begin{unbreakable}\begin{verbatim}
diff(3, t) + diff(sin(pi t), t)
0          + diff(sin(pi t), t)
             diff(pi t, t)                   fdiff(sin)(pi t)
             (pi diff(t, t) + t diff(pi, t)) fdiff(sin)(pi t)
             (pi diff(t, t) + t diff(pi, t))        cos(pi t)
             (pi 1          + t diff(pi, t))        cos(pi t)
             (pi            + t 0          )        cos(pi t)
             
pi cos(pi t)
\end{verbatim}\end{unbreakable}
\end{beispiel}

\subsection{Exakte Auswertung trigonometrischer Funktionen} \label{subsubsecCos}
Die Regeln zur Erkennung von Nullstellen und Extrempunkte der Kosinus-Funktion lassen sich sehr kompakt mit Wert-Mustervariablen beschreiben: 

\begin{unbreakable}\begin{verbatim}
cos(           pi)           = -1
cos(($k + 0.5) pi) | $k :int =  0
cos((2 $k)     pi) | $k :int =  1
cos((2 $k + 1) pi) | $k :int = -1
\end{verbatim}\end{unbreakable}

Eine alternative Regelmenge mit selbem Effekt nutzt Bedingungen.

\begin{unbreakable}\begin{verbatim}
cos(   pi)                     = -1
cos(_a pi) | _a + 1/2     :int =  0
cos(_a pi) | _a / 2       :int =  1
cos(_a pi) | (_a - 1) / 2 :int = -1
\end{verbatim}\end{unbreakable}

Bemerkenswert ist, dass in beiden Regelmengen dem System kein numerischer Wert für das Symbol \verb|pi| genannt wird.

\subsection{Faktorisieren}
Schwieriger in der Frage, ob jede Regelanwendung zu einer Vereinfachung führt, ist das Faktorisieren einer Summe aus Produkten. Wer dieser Frage unkritisch gegenübersteht, kann die folgenden Ersetzungsregeln nutzen.

\begin{unbreakable}\begin{verbatim}
_a^2 + 2 _a _b + _b^2 = (_a + _b)^2
_a^2 - 2 _a _b + _b^2 = (_a - _b)^2
$a^2 + 2 $a _b + _b^2 = ($a + _b)^2
$a^2 - 2 $a _b + _b^2 = ($a - _b)^2

_a bs... + _a cs... = _a (prod(bs...) + prod(cs...))
_a bs... + _a       = _a (prod(bs...) + 1)
_a       + _a       = 2 _a
\end{verbatim}\end{unbreakable}

Leider nicht direkt durch eine endliche Menge von Mustern abbildbar, ist der binomische Lehrsatz. Die ersten beiden binomischen Formeln sind durch die vier Regeln im ersten Block vollständig beschrieben. Die unteren beiden Regeln des Blocks erkennen die Formeln auch dann, wenn \verb|$a| nicht direkt vorliegt, sondern als Wert bereits mit seiner Umgebung kombiniert wurde. Anwendbar ist die dritte Regel etwa auf das Literal \verb|81 + 18 sin(x) + sin(x)^2| mit $v_p$ \verb|$a| $= 9$.

Die dargestellten Regeln müssen deshalb kritisch betrachtet werden, weil sie hochgradig nicht-konfluent sind, wie bereits in Abschnitt \ref{subsubsecKonfluenz} diskutiert. Eine einfache Ersetzung des ersten gefundenen Musters führt deshalb möglicherweise nicht immer zum bestmöglichen Ergebnis.


















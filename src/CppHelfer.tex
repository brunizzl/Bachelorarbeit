

\section{Sekundäre Konzepte mit Relevanz für die Umsetzung} \label{secHilfUmsetzungInCpp}

\subsection{Speicher} \label{subsecCppSpeicher}

\subsection{SumEnum} \label{subsecCppSumEnum}

\subsection{Lambdafunktionen} \label{subsecLambdafunktionen}
Muster sind dafür gebaut bestimmte Formen von Termen zu erkennen. Der Term, der aus einer Musteranwendung resultieren soll, ist allerdings nicht immer nur ein fester Ausdruck, dessen einzige Freiheitsgerade durch einfaches Ersetzen der im Match der linken Seite gebundenen Mustervariablen durch die entsprechenden Literale beschrieben werden kann. Ist eine umfassendere Transformation notwendig, wäre es mit der etablierten Musterersetzung möglich Helferfunktionen zu definieren. Von Vorteil ist die Nutzung der Musterersetzung allerdings nur dann, wenn auch in der Helferfunktion eine umfassende Fallunterscheidung gemacht werden muss. Die Vergrößerung der Menge der zu matchenden Muster hat allerdings nicht nur eine an die Geschwindigkeit der Mustererkennung gekoppelte Auswertungsgeschwindigkeit,  sondern gibt dem Funktionssymbol der Helferfunktion auch für die gesamte Regelmenge eine Bedeutung. 
Generische Namen wie \texttt{helper} für diese Art von Funktionssymbol sind fehleranfällig, da eine als Ersetzungsregel definierte Helferfunktion für die gesamte Regelmenge sichtbar ist. Die deutliche Abgrenzung der Namen von Helferfunktionen untereinander führt zu sehr verboser Namensgebung.
Das Konstrukt der separat definierten Helferfunktion auch für sehr einfache Abbildungsvorschriften wird deswegen als unelegant und fehleranfällig bewertet. 
Im Kontrast ist die rechte Seite einer Ersetzungsregel dann einfach zu lesen, wenn die genutzten Funktionssymbole eine bereits bekannte Bedeutung haben. Für Funktionssymbole wie \texttt{sum}, \texttt{prod} oder \texttt{pow} ist diese Bedeutung eingebaut, die Auswertungsregeln sind über die $\mathrm{eval}$ Funktion direkt implementiert. Die diskutierten Helferfunktionen ebendfalls auf diese Art einzubauen ist allerdings nicht praktikabel. Zum einen ist die Anforderung der begrenzten Sichtbarkeit dann noch weniger erfüllt: Ein Helfer wäre nicht nur für eine, sondern sogar alle Regelmengen sichtbar. Zum anderen ist die Implementierung eines Helfers über $\mathrm{eval}$ vergleichsweise sehr aufwendig und bietet neben logischen Fehlern im Helfer auch die Möglichkeit Fehler beim Umgang mit der unterliegenden Datenstruktur zu machen. Ziel ist also ein Konstrukt, was es erlaubt einfache Funktionen als Teil eines Musters zu definieren und über $\mathrm{eval}$ statt der Musterersetzung auswerten zu lassen. 
Ein Konzept welches diese Anforderungen erfüllt ist die Lambdafunktion, frei nach \cite{ChurchLambda36}. Im Kontext eines Terms ist eine Lambdafunktion primär ein Funktionsymbol, welches nur durch seine Stelligkeit und Abbildungsvorschrift identifiziert ist. Die Abbildungsvorschrift selbst ist ein Term, welcher neben sonst erlaubten Konstantensymbolen noch vom Lambda gebundene Variablen enthalten kann. Gleichzeitig ist ein Lambda allerdings auch ein gültiges Konstantensymbol, kann also selbst Parameter einer Funktionsanwendung sein.


\begin{definition}
Eine besondere Klasse von Funktionssymbolen und Konstantensymbolen ist die der Lambdas. Die Notation wird eingeleutet durch ein kleines Lambda, gefolgt von der Nennung der gebundenen Variablen. Der Term, der die Abbildungsvorschrift beschreibt folgt als letztes und ist durch ein Punkt von den Variablenbindungen getrennt. Auswertung der Funktionsanwendung eines Lambdas ist $\beta$-Reduktion. \BFred{Ich vermute sachen wie $\beta$-Reduktion oder DeBrujin sollten mit Quellen verknüpft sein?}
$$
\lambda \textit{Variablenname(n)}~.\textit{Abbildungsvorschrift}
$$
Als Beispiel bindet das Funktionssymbol $f = \lambda x y.(\texttt{pow}, x, y)$ die Variablen $x$ und $y$. Die Abbildungsvorschrift von $f$ ist $(x, y) \mapsto (\texttt{pow}, x, y)$, alternativ könnte man also schreiben $f = \texttt{pow}$. Wichtig ist, dass die hier definierten Lambdas in Abweichung vom Lambdakalkül auch mehrere Parameter direkt abbilden können. Während die Schreibweise eines einzelnen kleinen Lambdas gefolgt von mehreren Variablennamen in der Literatur also nur eine Kurzschreibweise für ein Lambda, welches den ersten Variablennamen bindet und auf ein Lambda, welches den zweiten Variablennamen bindet, abbildet, ist, werden hier tatsächlich mehrere Variablennamen von nur einem Lambda gebunden. Definiert man also $g = \lambda x.\lambda y.(\texttt{pow}, x, y)$ ist $f \neq g$, denn eine korrekte Funktionsanwendung von $f$ ist $(f, 1, 2)$, während $((g, 1), 2)$ eine korrekte Funktionsanwendung von $g$ ist\footnote{Sind Lambdas als Konstantensymbole erlaubt, muss dementsprechend die Definition eines Funktionssymbols entsprechend erweitert werden um die Funktionsanwendung einer Funktionsanwendung zu erlauben.}. \\
Intern werden für die Unterscheidung der in Lamdas gebundenen Variablen keine Zeichenketten, sondern DeBrujin Indizes verwendet. Mit DeBrujin Index als Index ergänzt ist $f = \lambda x_0 y_1.(\texttt{pow}, x_0, y_1)$ und $g = \lambda x_0.\lambda y_1.(\texttt{pow}, x_0, y_1)$ sowie $(g, 1) = \lambda y_0.(\texttt{pow}, 1, y_0)$.

Das Beispiel $g$ zeigt die definierende Eigenschaft der DeBrujin Indizes. Durch die Indexverschiebung der gebundenenen Variablen in einer geschachtelten Lambdadefinition um die Anzahl der bereits vorher gebundenen Variablen wird jede Variable eindeutig einer Lambdafunktion zugeordnet. Wird eine Funktionsanwendung eines Lambdas $f$ der Stelligkeit $n$ ausgewertet und befindet sich eine Variable mit DeBrujin Index $i > n$ in der Abbildungvorschrift von $f$, so wird die Variable nicht durch einen Parameter von der Funktionasanwendung von $f$ ersetzt, sondern nur $n$ von $i$ subtrahiert.
\end{definition}

Mit Lambdas als Konstantensymbolen ist es erlaubt, als Parameter der Funktionsanwendung eines Lambdas $a$ ein Lambda $p$ zu übergeben. Es gibt zwei Möglichkeiten die DeBrujin Indizes der von $p$ gebundenen Variablen nach Ersetzung anzupassen. 
Eine Möglichkeit ist, bei der Ersetzung der gebundenen Variablen während der Auswertung eines Lambdas immer die aktuelle Verschiebung mitzuschreiben und bei Ersetzung einer gebundenen Variable durch ein Lambda diese Verschiebung zu allen gebundenen Variablen im resultierenden Lambda dazuzuaddieren. Problem dieses Ansatzes ist zum einen, dass dann nicht nur getestet werden muss ob ein Parameter ein Lambda ist, sondern auch ob ein Parameter ein Lambda enthält. Diese Operation ist in ihrer Komplexität linear in der Anzahl der Funktionsanwendungen und Konstantensymbole des Parameters und deswegen unerwünscht. \\
Die implementierte Lösung des Problems unterscheidet stattdessen zwischen zwei Arten von Lambdas: Ein \emph{transparentes} Lambda ist ausschließlich in der Abbildungvorschrift eines weiteren Lambdas erlaubt. Es verhält sich wie erklärt, kann also auch Variablen enthalten, die vom umgebenden Lambda gebunden sind und hat dementsprechend auch die Indizes der selbst gebundenen Variablen um die Anzahl der weiter außen gebundenen Variablen verschoben. Ein Lambda, welches nicht Teil der Abbildungsvorschrit eines anderen Lamdas ist, ist nicht transparent. Hat es eine Stelligkeit von $n$, bindet also $n$ Variablen, haben diese die DeBrujin Indizes in $\{0, 1, \dots, n-1\}$. Die Funktionsanwendung eines Lambdas wird ausschließlich dann ausgewertet, wenn sie selbst nicht Teil einer Lambdadefinition ist, damit also auch nicht transparent ist. 
Enthält das Ergebnis einer solchen Funktionsauswertung transparente Lambdas, werden diese untransparent, wenn sie ihrerseits nach der Auswertung nicht mehr Teil einer Lambdadefinition sind. 
Ist ein Lambda $p$ Parameter der Funktionsanwendung eines Lambdas $a$, wird $p$ mit der Auswertung der Anwendung von $a$ an die entsprechenden Stellen der Abbildungsvorschrift von $a$ plaziert. Auch wenn diese entsprechenden Stellen innerhalb geschachtelter Lambdas liegen, wird keine Indexverschiebung der von $p$ gebundenen Variablen vorgenommen. $p$ hat sich vor der Auswertung von $a$ allerdings nicht innerhalb eines Lambdas befunden, sonst wäre auch $a$ innerhalb dieses selben Lambdas gewesen, hätte also nicht ausgewertet werden dürfen. Weder $p$, noch $a$ können damit transparent sein. Das nicht transparente Lambda $p$ darf innerhalb der Abbildungsvorschrift eines Lambdas $f$ liegen. Wird eine Funktionsanwendung von $f$ ausgewertet, Wird in $p$ aber nicht nach von $f$ gebundenen Variablen gesucht. In diesem Kontext ist auch die Benennung der Eigenschaft der Tranzparenz zu verstehen: Die Auswertung der Funktionsanwendung eines Lambdas probiert nur in transparenten Teilen der Abbildungvorschrift die gebundenen Variablen zu ersetzten.\\
Diese Verwaltungsstrategie hat den Vorteil, dass die Auswertung der Funktionsanwendung eines Lambdas die Parameter nicht verändern muss, in der Komplexität also auch nicht von der Größe der Parameter abhängt. Der Nachteil ist, dass Lambdas selber nicht normalisiert werden. Das ist allerdings für den geplanten Verwendungszweck ohnehin nicht erforderlich, da Lambdas nicht Teil des Ergebnisses einer Termtransformation sein sollen, sondern lediglich die Transformation selbst vereinfachen. \BFred{TODO: fasse Relation von a, f und p in Bilder}








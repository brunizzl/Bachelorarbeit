

\section{Patternmatching} \label{secPattermatching}

In Kapitel \ref{subsecMuster} wurde die Konzepte des Musters und des Matches eingeführt, zweiteres insbesondere in einer weiterfassenden Form, was auch erlaubt Muster mit strukturell nicht exakt identischen Literalen zu assoziieren, sofern die Unterschiede mit der Projektion $\mathrm{normalize} \colon T \rightarrow T$ beseitigt werden können. Die in Kapitel \ref{secErsteNormalform} beschriebene Funktion $\mathrm{normalize}$ ist als solche Projektion nutzbar. \BFred{soll ich eigentlich irgendwo noch einmal explizit motivieren, warum normalize eine Projektion ist / sein sollte?} 

In diesem Kapitel wird ein Algorithmus entwickelt, der die Äquivalenzklassen der verschieden geschachtelten Funktionsanwendungen eines assoziativen Funktionssymbols mit den selben Parametern, sowie die Äquivalenzklassen der verschieden permutierten Parameter in der Funktionasanwendung eines kommutativen Funktionssymbols beim finden eines Matches berücksichtigt. Die teilweise Auswertung von $\mathrm{normalize}$ aus Kapitel \ref{subsecNormalKombinieren} wird allerdings in diesem Kapitel nicht verfolgt.


%.........................................................................
%.........................................................................
%.........................................................................
\subsection{Grundstruktur} \label{subsecPatternmatchingGrundstruktur}

Dem Ergebnis eines Matchalgorithmus müssen zwei Dinge entnehmbar sein. Zum ersten muss klar sein, ob ein Match $v_p \colon X \rightarrow T$ gefunden wurde. Wurde ein Match gefunden, muss zudem dessen Abbildungsvorschrift zurückgegeben werden. Der Rückgabetyp von Algorithmus \ref{simpleMatchAlgorithmShell} ist deswegen nicht nur das finale Match, sondern auch ein Wahrheitswert $b \in \mathit{Bool} \coloneqq \{\mathrm{false}, \mathrm{true}\}$. Alternativ kann die Menge aller möglichen Matches zurückgegeben werden. Diese Idee wird im folgenden allerdings nicht weiter verfolgt, da sie mit den Anforderungen an hier behandelte Muster auch im besten Fall schnell exponentielle Laufzeiten produziert. Sind aber Mehrfachnennungen einer Mustervariable in einem Muster nicht erlaubt, haben Hoffman und O'Donnell in \cite{patternMatchingInTrees} gezeigt, dass sehr effiziente Algorithmen zum gleichzeitigen finden von Matches einer ganzen Menge von Mustern in allen Teiltermen eines Literals mit dieser Grundidee möglich sind.\\

Da eine Mustervariable in dieser Arbeit mehrfach in einem Muster vorkommen darf, muss ein Algorithmus beim Suchen nach einem Match $v_p \colon X \rightarrow T$ zu jedem Zeitpunkt wissen, für welche $x \in X$ das Match $v_p~x$ bereits feststeht. $v_p$ ist also nicht nur Rückgabewert eines Matchalgorithmus, sondern muss mit den Funktionswerten für bereits besuchte Mustervariablen auch Eingabe in den Algorithmus sein. In Algorithmus \ref{simpleMatchAlgorithmShell} wird $v_p$ deswegen als partielle Funktion definiert, welche zu Beginn keine einzige Mustervariable nach $T$ abbilden kann. \\

\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{simpleMatchAlgorithmShell} \colon M \times T \rightarrow (\mathit{Bool}, X \rightharpoonup T)$}\label{simpleMatchAlgorithmShell}
\KwIn{$p \in M$, $t \in T$}

\textbf{let} $v_p \colon X \rightharpoonup T,~ x \mapsto \bot$\;
\Return {$\mathrm{simpleMatchAlgorithm}(p, t, v_p)$}
\end{algorithm}

\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{simpleMatchAlgorithm} \colon M \times T \times (X \rightharpoonup T) \rightarrow (\mathit{Bool}, X \rightharpoonup T)$}\label{simpleMatchAlgorithm}
\KwIn {$p \in M$, $t \in T$, $v_p \colon X \rightharpoonup T$}

\If {$p \in X$ \KwAnd $v_p~p = \bot$}{\label{simpleBindend}
    $(v_p~p) \leftarrow t$\;
    \Return {$(\mathrm{true}, v_p)$}
}
\ElseIf {$p \in X$ \KwAnd $v_p~p \neq \bot$}{ \label{simpleNichtBindend}
    \Return {$(v_p~p = t, v_p)$}
}
\ElseIf {$p \in C \setminus X$} {
    \Return {$(p = t, v_p)$}
}
\ElseIf {$p = (f, \elems p 0 {m-1})$ \KwAnd $t = (f, \elems t 0 {n-1})$}{
    \For {$k \in \{0, \dots, {n-1}\}$}{
        $(\mathit{success}_k, v_p) \leftarrow \mathrm{simpleMatchAlgorithm}(m_k, t_k, v_p)$\;
        \If {$\mathrm{not}~\mathit{success}_k$}{
            \Return {$(\mathrm{false}, v_p)$}
        }
    }
    \Return {$(\mathrm{true}, v_p)$}  
}
\Else {
    \Return {$(\mathrm{false}, v_p)$}  
}
\end{algorithm}


Wenn das Match streng definiert ist, also der Unterschied zwischen einem Muster $p$ und einem Literal $t$ für die Existenz eines Matches $v_p$ aussschließlich darin bestehen darf, dass Teilterme von $t$ in $p$ durch eine Mustervariable repräsentiert werden, ist ein einfacher Matchalgorithmus fast trivial. Auf der Grundidee von $\mathrm{simpleMatchAlgorithm}$ basieren allerdings auch die späteren Algorithmen dieses Kapitels. Diese ist, dass mit einer parralelen Tiefensuche in Muster und Literal nach einem Unterschied zwischen beiden gesucht wird. Mustervariablen funktionieren dabei als Wildcard, wenn eine identische Mustervariable in der Tiefensuche vorher noch nicht gefunden wurde. Andernfalls vergleichen sie identisch zu dem Teilbaum, der mit dem ersten Vorkommen der Mustervariable verglichen wurde. Die Aufgabe diese vorher begegneten Teilbäume zu speichern übernimmt $v_p$, was erklärt, warum $v_p$ auch als Parameter für Algorithmus \ref{simpleMatchAlgorithm} notwendig ist. Ist das gesamte Muster abgelaufen worden ohne einen strukturellen Unterschied zum Literal zu finden, ist $v_p$ das resultierende Match.\\

\newtheorem{lemMatchLinear}[bsp]{Lemma}
\begin{lemMatchLinear}~\\
Die Laufzeit von Algorithmus \ref{simpleMatchAlgorithmShell} ist linear abhängig von der Anzahl der Funktionssymbole und Konstantensymbole des Literals.
\end{lemMatchLinear}

\newtheorem{bewNatchLinear}[bsp]{Beweis}
\begin{bewNatchLinear}~\\
Gibt es ein Match, wird jedes Funktionssymbol und Konstantensymbol des Literals höchstens ein mal in simpleMatchAlgorithm abgelaufen. Wird eine Funktionsanwendung $t$ im Literal parrallel zu einer Mustervariable $\mathbf x$ im Muster abgelaufen, bleiben die Nachkommen von $t$ unbesucht wenn $\mathbf x$ noch nicht gematcht wurde. Andernfalls wird jeder Nachkomme von $t$ höchstens ein mal abgelaufen, um Gleichheit zu $v_p~\mathbf x$ zu testen.
Gibt es kein Match wird das Literal so lange indentisch zum anderen Fall abgelaufen, bis ein struktureller Unterschied festgestellt wurde. Dann bricht der Algorithmus ab.
\hfill $\square$\\
\end{bewNatchLinear}



%.........................................................................
%.........................................................................
%.........................................................................
\subsection{Multi-Mustervariablen} \label{subsecMulti}

Von Anfang an werden Funktionssymbole in dieser Arbeit als möglicherweise variadisch definiert. Das ist in sofern ein Problem, als Muster bisher immer nur eine feste Anzahl an Parametern für jede Funktionsanwendung angeben können. Ist ein variadisches Funtionssymbol zudem assoziativ, ließe sich dieses Problem prinzipiell beheben, wenn Assoziativität im Matchalgorithmus berücksichtigt würde. Das Muster $\tilde p = (f, \mathbf x, \mathbf y)$ würde für ein assoziatives Funktionssymbol $f$ dann auch Literale wie $\tilde t = (f, a, b, c, d)$ matchen, mit verschiedenen Optionen für $v_p$, etwa $v_p~\mathbf x = (f, a, b)$ und $v_p~\mathbf y = (f, c, d)$. Ist auch die leere Funktionsanwendung $(f)$ von $f$ erlaubt \footnote{Das ergibt dann Sinn, wenn $f$ ein neutrales Element $e \in T$ besitzt, da $(f, as..., (f), bs...)$ mit $\mathrm{normalize}$ zu $(f, as..., bs...) = (f, as..., e, bs...)$ umgeformt wird. Im Folgenden wird von der Existenz eines Neutralen Elementes ausgegangen.}, gäbe es fünf verschiedene Matches $v_p$ für $\paren*{\tilde p, \tilde t}$ mit nicht kommutativem $f$.

\newtheorem{lemNummerMatchesAC}[bsp]{Lemma}
\begin{lemNummerMatchesAC}~\\
Das Muster $p = (f, \elems {\mathbf x} 1 m)$ hat mit dem Literal $t = (f, \elems a 1 n)$ genau ${m + n - 1}\choose n$ mögliche Matches, wenn $f$ assoziativ aber nicht kommutativ ist $(1)$. Ist $f$ assoziativ und kommutativ gibt es $m^n$ mögliche Matches $(2)$.\\
\end{lemNummerMatchesAC}

\newtheorem{bewNummerMatchesAC}[bsp]{Beweis}
\begin{bewNummerMatchesAC}~\\
$(1)$: Es gibt $m$ möglicherweise leere Abschnitte in den $n$ Parametern von $t$, welche jeweils eine Mustervariable $\mathbf x_i$ matchen. Stellt man eine Abschnittsgrenze mit einem Strich $~|~$ und ein Parameter von $t$ mit einem Stern $~*~$ dar, kann die Aufteilung der Parameter von $t$ über ein String aus $m - 1$ Strichen und $n$ Sternen dargestellt werden. 
Als Beispiel ist $~**|**~$ der String zur Aufteilung von $\tilde t$ aus dem Anfang des Abschnittes zum beschriebenen Match $v_p$.
Es gibt ${m + n - 1}\choose n$ Möglichkeiten die $n$ Sterne auf die ${m + n - 1}$ möglichen Plätze zu verteilen.\\

$(2)$: Jeder der $n$ Parameter von $t$ kann unabhängig der restlichen Parametern zu einer der $m$ Mustervariablen gematcht werden. Insgesamt ergeben sich so $m^n$ Kombinationen.
\hfill $\square$\\
\end{bewNummerMatchesAC}

Schon für nicht kommutative aber assoziative Funktionssymbole $f$ gibt es somit Muster $p$ mit einer Anzahl möglicher Matches, die exponentiell mit der Größe des Literals steigt. Ist ein solches Muster $p$ Teil eines größeren Musters $p'$ und kommen Mustervariablen von $p$ auch in anderen Teilen von $p'$ vor, so ist nicht direkt ersichtlich, wie ein Algorithmus aussehen würde, der in polinomieller Zeit bestimmen kann, dass es kein Match für $p'$ mit einem entsprechenden Literal gibt, bzw. das Match findet. Die Existenz eines solchen Algorithmus ist unwarscheinlich: Benanav hat 1987 gezeigt, dass das Problem NP-schwer ist \cite{NPHardMatching}.
Von dem perfekten Matchalgorithmus wird aus diesem Grund abgesehen. Für viele Spezialfälle sind allerdings bessere Algorithmen möglich. Eine wichtige Klasse solcher Spezialfälle ist die, wo von vorne herein klar ist, welche Mustervariable möglicherweise mehrere Parameter des Literals matchen soll. Würde man etwa bei der Ersetzung der ersten Binomischen Formel eine weitere Mustervariable $\mathbf c$ hinzufügen, um die Binomische Formel auch in einer Summe mit mehr als drei Summanden zu erkennen, sähe die Ersetzungregel wiefolgt aus.
$$(\texttt{sum}, (\texttt{pow}, \mathbf a, 2), (\texttt{prod}, 2, \mathbf a, \mathbf b), (\texttt{pow}, \mathbf b, 2), \mathbf c) \mapsto (\texttt{sum}, (\texttt{pow}, (\texttt{sum}, \mathbf a, \mathbf b), 2), \mathbf c)$$
$\mathbf c$ ist damit vom Autor des Musters ausschließlich dazu gedacht überbleibende Summanden \glqq aufzusaugen\grqq{}. Dieser Gedanke bleibt aber bisher dem Algorithmus verborgen.
Die in dieser Arbeit gewählte Lösung zur Beschreibung von beliebig vielen Parametern in einem Muster ist im Prinzip schon in Kapitel \ref{secErsteNormalform} eingeführt worden. Die Schreibweise $(f, ts...)$ als kompakte Alternative zu $(f, t_1, \dots, t_n)$ hat viele zur Beschreibung von Assoziativität gewünschte Eigenschaften. Ferner können so auch Muster mit nicht assoziativen variadischen Funktionssymbolen dargestellt werden. Eine \textit{Multi-Mustervariable} der Form $\mathbf{xs...}$ kann also nicht nur genau einen Parameter in einer Funktionsanwendung matchen, sondern beliebig viele, auch null. Um den Matchalgorithmus nicht zu kompliziert zu gestalten, darf jede Multi-Mustervariable auf der linken Seite einer Ersetzungsregel nur höchstens ein Mal vorkommen\footnote{Das macht zudem mehrere Multi-Mustervariablen in der selben Funktionsanwendung eines kommutativen Funktionssymbols auf der linken Seite einer Ersetzungsregel überflüssig. Diese Konstellation ist dementsprechend im Folgenden nicht berücksichtigt.}. Die rigorose Beschreibung des Konzeptes gestaltet sich allerdings mit der bisher eingeführten Ideen schwierig, da eine Multi-Mustervariable nur Teil einer Funktionsanwendung ist und damit auch alleine keinen vollständigen Term repräsentiert. Konnte eine Matchfunktion $v_p \colon X \rightarrow T$ vorher einfach auf die Menge aller Terme abbilden, wäre dies nach hinzufügen der Multi-Mustervariablen nicht mehr möglich. Entsprechend umständlicher würde auch die Beschreibung der Auswertung eines Musters werden. \\

Formal wird die Multi-Mustervariable damit nicht als echtes neues Symbol in die Menge der Muster aufgenommen, sondern ist lediglich eine vereinfachende Schreibweise, die wie auch vorher immer für eine beliebige Anzahl an Teiltermen steht, in diesem Fall Mustervariablen. Ein Muster mit einer Multi-Mustervariable $\mathbf{xs...}$ repräsentiert also formal unendlich viele konkrete Muster mit konkreten Mustervariablen $\mathbf{x_i}$:
\begin{equation*}
    \begin{split}
    		(f, \mathbf{ts...}) = \{&(f), \\
    		&(f, \mathbf{x_1}),\\
    		&(f, \mathbf{x_1}, \mathbf{x_2}), \\
    		&(f, \mathbf{x_1}, \mathbf{x_2}, \mathbf{x_3}), \\
    		&\dots \}    		
    \end{split}
\end{equation*}
Für die folgenden Algorithmen dieses Kapitels, sowie der echten Umsetzung, ist es allerdings nicht praktikabel diese Definition anzuwenden. Mit der Restriktion, dass jede Multi-Matchvariable auf der linken Seite einer Ersetzungsregel höchstens ein Mal vorkommen darf, ist eine sehr einfache Verwaltung möglich. Für Funktionsanwendungen kommutativer Funktionssymbole in einem Muster muss lediglich zwischen \emph{enthält eine Multi-Matchvariable} und \emph{enthält keine Multi-Matchvariable} unterschieden werden. Multi-Matchvariablen in Funktionsanwendungen nicht kommutativer Funktionssymbole haben allerdings eine eindeutige Position. Im folgenden werden aber auch hier keine weitern Parameter für Multi-Matchvariablen hinzugefügt. Alternativ wird für jeden tatsächlichen Term in den Parametern einer solchen Funktionsanwendung festgehalten, ob er Nachfolger einer Multi-Matchvariable ist und weiter, ob an dem letzten Parameter noch eine Multi-Matchvariable anschließt. 
Die Ersetzungsregel für die erste Binomischen Formel anwendbar auf Summen beliebiger Länge wird wiefolgt geschrieben.
$$(\texttt{sum}, (\texttt{pow}, \mathbf a, 2), (\texttt{prod}, 2, \mathbf a, \mathbf b), (\texttt{pow}, \mathbf b, 2), \mathbf{cs...}) \mapsto (\texttt{sum}, (\texttt{pow}, (\texttt{sum}, \mathbf a, \mathbf b), 2), \mathbf{cs...})$$
Die Summe der linken Seite setzt sich für die folgenden Algorithmen dieses Kapitels dennoch nur aus drei Summanden zusammen. Die syntaktisch als Parameter geschriebenen $\mathbf{cs...}$ kommen hier in der linken Seite der Regel nur als Wahrheitswert vor, denn es gilt \glqq Die Summe \emph{enthält eine Multi-Matchvariable}\grqq{}. Lediglich auf der rechten Seite ist relevant, um welche Multi-Matchvariable es sich handelt, sollte es mehrere geben. Dieses Kapitel befasst sich allerdings ausschließlich mit der linken Seite einer Regel.



%.........................................................................
%.........................................................................
%.........................................................................
\subsection{Kommutative Muster} \label{subsecACMuster}

\newtheorem{defBindend}[bsp]{Definition}
\begin{defBindend}~\\
Die Instanz einer Mustervariable $\mathbf x$ wird als \emph{bindend}  bezeichnet, wenn sie in einer Tiefensuche durch das gesamte Muster als erste Instanz abgelaufen wird. Da Algorithmus \ref{simpleMatchAlgorithm} das Muster in einer Tiefensuche abläuft, ist Zeile \ref{simpleBindend} damit genau dann wahr, wenn $p$ bindend ist\footnote{Der Begriff \emph{bindend} ist so zu verstehen, dass $\mathbf x$ nach Ablauf der ersten Instanz in Algorithmus \ref{simpleMatchAlgorithm} einen festen Wert $v_p~\mathbf x$ hat, also für den spätere Teile des Musters an diesen Wert gebunden ist.}. Weitere Instanzen von $\mathbf x$ im selben Muster werden als \emph{gebunden} bezeichnet.
\end{defBindend}

Abweichend von bisherigen Algorithmen wird von hier an in der Notation nicht mehr jede in echt notwendige Information explizit übergeben. Als Beispiel muss $v_p$ nach wie vor von jedem Funktionsaufruf aktualisiert werden, ist aber im Pseudocode der Algorithmen \ref{findMatch}, \ref{findPermutation}, \ref{findDilation}, etc. nicht länger explizit in Parameterliste oder als Rückgabewert erwähnt.
Anstelle der konkreten Zuweisung eines Wertes zu einem Namen, dargestellt duch den Pfeil nach links \glqq $\leftarrow$\grqq{}, wird die Veränderung einer solchen nich explizit erwähnten Datenstruktur nur mit dem Wort \glqq merke\grqq{} dargestellt.
 
\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{findMatch} \colon M \times T \rightarrow \mathit{Bool}$}\label{findMatch}
\KwIn {$p \in M$, $t \in T$}

\If {$p \in X$ \KwAnd $p$ bindend}{
    merke: $v_p~p = t$\;
    \Return {$\mathrm{true}$}
}
\ElseIf {$p \in X$ \KwAnd $p$ gebunden}{
    \Return {$v_p~p = t$}
}
\ElseIf {$p \in C \setminus X$} {
    \Return {$p = t$}
}
\ElseIf {$p = (f, \elems p 0 {m-1})$ \KwAnd $t = (f, \elems t 0 {n-1})$}{
    \If {$u~f$ kommutativ} {
        \Return {$\mathrm{findPermutation}(p, t, \mathrm{false})$}
    }
    \ElseIf {$\elems t 1 n$ enthalten Multi-Matchvariablen} {
        \Return {$\mathrm{findDilation}(p, t, \mathrm{false})$}
    }
    \ElseIf {$m = n$} {
        \Return {$\mathrm{findBacktracking}(p, t, \mathrm{false})$}
    }
}
\Return{$\mathrm{false}$}  
\end{algorithm}

\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{rematch} \colon M \times T \rightarrow \mathit{Bool}$}\label{rematch}
\KwIn {$p \in M$, $t \in T$}
\If {$p = (f, \elems p 0 {m-1})$ \KwAnd $t = (f, \elems t 0 {n-1})$} {
    \If {$u~f$ kommutativ} {
        \Return {$\mathrm{findPermutation}(p, t, \mathrm{true})$}
    }
    \ElseIf {$\elems t 1 n$ enthalten Multi-Matchvariablen} {
        \Return {$\mathrm{findDilation}(p, t, \mathrm{true})$}
    }
    \ElseIf {$m = n$} {
        \Return {$\mathrm{findBacktracking}(p, t, \mathrm{true})$}        
    }
}        
\Return {$\mathrm{false}$}  
\end{algorithm}

\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{findPermutation} \colon M \times T \times \mathit{Bool} \rightarrow \mathit{Bool}$}\label{findPermutation}
\KwIn {$p = (f, \elems p 0 {m-1}) \in M$, $t = (f, \elems t 0 {n-1}) \in T$, $\mathit{findRematch} \in \mathit{Bool}$}
\Let {$i \leftarrow 0$, $k \leftarrow 0$}\;
\If {$\mathit{findRematch}$} {
    $i \leftarrow m$\;
    \Goto {\ref{permutationRematchMuster}}\;
}
 \If {$m > n$} {
    \Return {$\mathrm{false}$}
 }
 \nlset{matche $p_i$} \While {$i < m$} {\label{PermutationHauptschleifenbeginn}
    \While {$k < n$} {
        \If {$t_k$ ist mit keinem Parameter von $p$ gematcht} {
            \If {$\mathrm{findMatch}(p_i, t_k)$} {
                \Goto {\ref{permutationNaechstesMuster}}\;
            }
        }
        $k \leftarrow k + 1$\;
    }
    \nlset{zurück} \If {$i = 0$} { \label{permutationRematchMuster}
        \Return {$\mathrm{false}$}
    }
    $i \leftarrow i - 1$\;
    {$k \leftarrow k'$ aus \glqq $p_{i}$ ist mit $t_{k'}$ gematcht\grqq{}}\;
    \If {not $\mathrm{rematch}(p_{i}, t_{k})$} {
        merke: $p_{i}$ ist nicht mehr mit $t_{k}$ gematcht\;
        $k \leftarrow k + 1$\;
        \Goto {\ref{PermutationHauptschleifenbeginn}}\;
    } 
    \nlset{weiter} merke: $p_i$ ist mit $t_k$ gematcht\; \label{permutationNaechstesMuster}
    $i \leftarrow i + 1$\;
    $k \leftarrow 0$\;    
 }
 \Return {$p$ enthält eine Multi-Matchvariable \KwOr alle $t_k$ wurden gematcht}
\end{algorithm}




\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{findDilation} \colon M \times T \times \mathit{Bool} \rightarrow \mathit{Bool}$}\label{findDilation}
\KwIn {$p = (f, \elems p 0 {m-1}) \in M$, $t = (f, \elems t 0 {n-1}) \in T$}
\If {$\mathit{findRematch}$} {
    $i \leftarrow m$\;
    \Goto {\ref{dilationRematchLastNeedle}}\;
}
\If {$m = 0$} {
    \Return {$\mathrm{true}$}
}
\If {$n = 0$} {
    \Return {$\mathrm{false}$}
}
\nlset{matche $p_i$} \If {$k < n$} { \label{dilationMatchCurrentNeedle}
    \DoWhile {$p_i$ ist Nachfolger einer Multi-Matchvariable \KwAnd $k < n$} { 
        \If {$\mathrm{findMatch}(p_i, t_k)$} {
            \Goto {\ref{dilationPrepareNextNeedle}}\;
        }
        $k \leftarrow k + 1$\;
    }
}
\nlset{zurück} \While {$i \neq 0$} { \label{dilationRematchLastNeedle}
    $i \leftarrow i - 1$\;
    {$k \leftarrow k'$ aus \glqq $p_{i}$ ist mit $t_{k'}$ gematcht\grqq{}}\;
    \If {$\mathrm{rematch}(p_i, t_k)$} {
        \Goto {\ref{dilationPrepareNextNeedle}}\;
    }
    \ElseIf {$p_i$ ist Nachfolger einer Multi-Matchvariable} {
        $k \leftarrow k + 1$\;
    \Goto {\ref{dilationMatchCurrentNeedle}}\;
    }
}
\Return{$\mathrm{false}$}\;
\nlset{weiter} merke: $p_i$ ist mit $t_k$ gematcht\; \label{dilationPrepareNextNeedle}
$i \leftarrow i + 1$\;
$k \leftarrow k + 1$\;
\If {$i \neq m$} {
    \Goto {\ref{dilationMatchCurrentNeedle}}\;
}
\ElseIf {$k \neq n$ \KwAnd nach $p_{m-1}$ folgt keine Multi-Matchvariable} {
    \Goto {\ref{dilationRematchLastNeedle}}\;
}
\Return {$\mathrm{true}$}
\end{algorithm}




\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{findBacktracking} \colon M \times T \times \mathit{Bool} \rightarrow \mathit{Bool}$}\label{findBacktracking}
\KwIn {$p = (f, \elems p 0 {n-1}) \in M$, $t = (f, \elems t 0 {n-1}) \in T$, $\mathit{findRematch} \in \mathit{Bool}$}
\Let {$i \leftarrow 0$}\;
\If {$\mathit{findRematch}$} {
    $i \leftarrow n$\;
    \Goto {\ref{backtrackRematchMuster}}\;
}
\Loop {} {
    \While {$\mathrm{findMatch}(p_i, t_i)$} {
        $i \leftarrow i + 1$\;
        \lIf {i = n} {\Return {$\mathrm{true}$}}    
    }
    \nlset{zurück} \DoWhile {not $\mathrm{rematch}(p_i, t_i)$} { \label{backtrackRematchMuster}
        \lIf {i = 0} {\Return {$\mathrm{false}$}}
        $i \leftarrow i - 1$\;
    }    
    $i \leftarrow i + 1$\;
}
\end{algorithm}

\newtheorem{lemKomplexitaetKomm}[bsp]{Lemma}
\begin{lemKomplexitaetKomm}\label{lemKomplexitaetKomm}~\\
Die Laufzeitkomplexität von Algorithmus \ref{findMatch} ist \BFred{TODO}
\end{lemKomplexitaetKomm}

\newtheorem{bewKomplexitaetKomm}[bsp]{Beweis}
\begin{bewKomplexitaetKomm}~\\
\BFred{TODO: beweise Lemma \ref{lemKomplexitaetKomm}}
\end{bewKomplexitaetKomm}

%.........................................................................
%.........................................................................
%.........................................................................
\subsection{Bessere Laufzeit für kommutative Muster} \label{subsecCMuster}

Recht einfach zu implementieren ist ein Matchalgorithmus, der bei kommutativen Funktionssymbolen für jede Permutation der Parameter prüft, ob ein Match existiert. Ziel dieses Abschnittes ist, a priori möglichst viele Reihenfolgen der Parameter des Musters auszuschließen, dann also auch nicht prüfen zu müssen. Vorraussetzung dafür ist, dass sowohl Muster als auch Literal mit $\mathrm{normalize}$ aus Kapitel \ref{secErsteNormalform} normalisiert werden. Insbesondere die Sortierung ist relevant. Abweichend von Abschnitt \ref{subsecNormalSortieren} wird im folgenden allerdings eine Ordnung verwendet, die Mustervariablen hinter jede andere Art von Term sortiert.
Bestimmte Muster mit kommutativen Funktionssymbolen können mit dieser einfachen Maßname bereits in linearer Zeit mit einem Literal abgeglichen werden. Besteht ein Muster etwa aus der Anwendung eines komutativen Funktionssymbols $f$ auf $m$ Parameter $\elems p 1 m$ und sind die Parameter $p_i$ ausschließlich Funktionsanwendungen paarweise verschiedener Funktionssymbole, ist garantiert, dass die Parameter eines Literals für ein Match in der selben Reihenfolge liegen müssen. Wenn auch alle Teilmuster $p_i$ dieser Struktur folgen, bzw. nicht kommutativ sind, wird ein Match zuverlässig bereits mit Algorithmus \ref{simpleMatchAlgorithmShell} gefunden\footnote{unter der Annahme, dass keine assoziativen Funktionssymbole im Muster enthalten sind}. Das liegt daran, dass für alle $i, j \in \{1, \dots, m\}, i < j$ gilt, dass $p_i$ ausschließlich Literale matchen kann, die vor jedes Literal sortiert werden, welches mit $p_j$ gematcht werden könnte. Diese Idee der Ordnung zweier Muster wird im folgenden ausgeführt.


\newtheorem{defStarkGeordnet}[bsp]{Definition}
\begin{defStarkGeordnet}~\\
Gilt für zwei Muster $p_1, p_2 \in M(F, C)$, dass alle Literale $t_1, t_2 \in T(F, C)$ für die es jeweilige Matchfunktionen $v_{p_1}, v_{p_2} \colon X \rightarrow T(F, C)$ gibt, $t_1 < t_2$ erfüllen, so ist $p_1$ \emph{stark kleiner} als $p_2$, geschrieben $p_1 \prec p_2$. Mit  $t_1 \leq t_2$ ist $p_1$ \emph{stark kleiner gleich} als $p_2$, geschrieben $p_1 \preceq p_2$.
\end{defStarkGeordnet}

Für folgende Formen von Mustern $p$ und $q$ gilt $p \prec q$:
\begin{itemize}
    \item{$p$ und $q$ enthalten keine Mustervariablen und $p \neq q$}
    
    \item{$p$ ist ein Konstantensymbol aber keine Mustervariable und $q$ ist eine Funktionsanwendung}
    
    \item{$p$ und $q$ sind Funktionsanwendungen verschiedener Funktionssymbole $f$ und $g$ mit $f < g$}
    
    \item{$p = (f, \elems p 1 m)$ und $q = (f, \elems q 1 n)$ sind Funktionsanwendungen des selben nicht kommutativen Funktionssymbols $f$ und $m < n \land \forall j \in \{1, \dots, m\} \colon p_j = q_j$}
    
    \item{$p = (f, \elems p 1 m)$ und $q = (f, \elems q 1 n)$ sind Funktionsanwendungen des selben nicht kommutativen Funktionssymbols $f$ und $\exists i \leq min\{n, m\} \colon p_i \prec q_i \land \forall j \in \{1, \dots, i  - 1\} \colon p_j = q_j$}
    
    \item{$p = (g, \elems p 1 m)$ und $q = (g, \elems q 1 n)$ sind Funktionsanwendungen des selben kommutativen Funktionssymbols $g$ und $\forall i \in \{1, \dots, m\}, j \in \{1, \dots, n\} \colon p_i \prec q_j \lor p_i = q_j$}
    
    \item{\BFred{TODO: was ist mit kommutativen Funktionssymbolen? (die Regel hier drüber ist SEHR konservativ)}}
\end{itemize}

\BFred{TODO: Beweise $p \prec q$ in beschriebenen Fällen}


Für folgende Formen von Mustern $p$ und $q$ gilt $p \preceq q$:
\begin{itemize}
    \item{$p \prec q$}
    
    \item{$p = q$}
    
    \item{kontextabhängig, wenn $p = \mathbf x$ und $q = \mathbf y$ Mustervariablen sind und das gesamte Muster $r$, in dem sowohl $p$ als auch $q$ sich befinden \emph{symmetrisch} zu $\mathbf x$ und $\mathbf y$ ist. Symmetrisch ist $r$ dann, wenn $\mathbf x$ und $\mathbf y$ in ganz $r$ getauscht werden können um $r'$ zu erhalten und die normalisierte Form von $r'$ identisch zu $r$ ist.}
\end{itemize}

\BFred{TODO: Beweise $p \preceq q$ in beschriebenen Fällen}

Beispiele für symmetrische Muster sind beide Seiten der ersten Binomischen Formel, wobei $\mathbf a$ symmetrisch zu $\mathbf b$ ist:
$$(\texttt{sum}, (\texttt{pow}, \mathbf a, 2), (\texttt{prod}, 2, \mathbf a, \mathbf b), (\texttt{pow}, \mathbf b, 2), \mathbf {c...}) \mapsto (\texttt{sum}, (\texttt{pow}, (\texttt{sum}, \mathbf a, \mathbf b), 2), \mathbf {c...})$$


\newtheorem{lemTransitivStark}[bsp]{Lemma}
\begin{lemTransitivStark}~\\
Für Muster $p, q, r \in M$ mit $p \prec q \leq r$ folgt $p \prec r$ $(1)$. In die andere Richtung folgt zudem aus $p \leq q \prec r$ dass $p \prec r$ $(2)$.
\end{lemTransitivStark}

\newtheorem{bewTransitivStark}[bsp]{Beweis}
\begin{bewTransitivStark}~\\
\BFred{TODO: beweise Lemma \ref{lemTransitivStark}}
\end{bewTransitivStark}

























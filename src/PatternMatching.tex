

\chapter{Mustererkennung} \label{secPattermatching}

In Kapitel \ref{subsecMuster} wurde die Konzepte des Musters und des Matches eingeführt, zweiteres insbesondere in einer weiterfassenden Form, was auch erlaubt Muster mit strukturell nicht exakt identischen Literalen zu assoziieren, sofern die Unterschiede mit der Projektion $\mathrm{normalize} \colon T \rightarrow T$ beseitigt werden können. Die in Kapitel \ref{secErsteNormalform} beschriebene Funktion $\mathrm{normalize}$ ist als solche Projektion nutzbar.  

In diesem Kapitel wird ein Algorithmus entwickelt, der die Äquivalenzklassen der verschieden geschachtelten Funktionsanwendungen eines assoziativen Funktionssymbols mit den selben Parametern, sowie die Äquivalenzklassen der verschieden permutierten Parameter in der Funktionsanwendung eines kommutativen Funktionssymbols beim Finden eines Matches berücksichtigt. Die teilweise Auswertung von $\mathrm{normalize}$ aus Kapitel \ref{subsecNormalKombinieren} wird allerdings in diesem Kapitel nicht verfolgt.


%.........................................................................
%.........................................................................
%.........................................................................
\section{Grundstruktur} \label{subsecPatternmatchingGrundstruktur}

Dem Ergebnis eines Matchalgorithmus müssen zwei Dinge entnehmbar sein. Zum ersten muss klar sein, ob ein Match $v_p \colon X \rightarrow T$ gefunden wurde. Wurde ein Match gefunden, muss zudem dessen Abbildungsvorschrift zurückgegeben werden. Der Rückgabetyp von Algorithmus \ref{simpleMatchAlgorithmShell} ist deswegen nicht nur das finale Match, sondern auch ein Wahrheitswert $b \in \mathit{Bool} \coloneqq \{\mathrm{false}, \mathrm{true}\}$. Alternativ kann die Menge aller möglichen Matches zurückgegeben werden. Diese Idee wird im Folgenden allerdings nicht weiter verfolgt, da sie mit den Anforderungen an hier behandelte Muster auch im besten Fall schnell exponentielle Laufzeiten produziert. Sind aber Mehrfachnennungen einer Mustervariable in einem Muster nicht erlaubt, haben Hoffman und O'Donnell in \cite{patternMatchingInTrees} gezeigt, dass sehr effiziente Algorithmen zum gleichzeitigen finden von Matches einer ganzen Menge von Mustern in allen Teiltermen eines Literals mit dieser Grundidee möglich sind.\\

Da eine Mustervariable in dieser Arbeit mehrfach in einem Muster vorkommen darf, muss ein Algorithmus beim Suchen nach einem Match $v_p \colon X \rightarrow T$ zu jedem Zeitpunkt wissen, für welche $x \in X$ das Match $v_p~x$ bereits feststeht. $v_p$ ist also nicht nur Rückgabewert eines Matchalgorithmus, sondern muss mit den Funktionswerten für bereits besuchte Mustervariablen auch Eingabe in den Algorithmus sein. In Algorithmus \ref{simpleMatchAlgorithmShell} wird $v_p$ deswegen als partielle Funktion definiert, welche zu Beginn keine einzige Mustervariable nach $T$ abbilden kann. \\

\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{simpleMatchAlgorithmShell} \colon M \times T \rightarrow (\mathit{Bool}, X \rightharpoonup T)$}\label{simpleMatchAlgorithmShell}
\KwIn{$p \in M$, $t \in T$}

\textbf{let} $v_p \colon X \rightharpoonup T,~ x \mapsto \bot$\;
\Return {$\mathrm{simpleMatchAlgorithm}(p, t, v_p)$}
\end{algorithm}

\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{simpleMatchAlgorithm} \colon M \times T \times (X \rightharpoonup T) \rightarrow (\mathit{Bool}, X \rightharpoonup T)$}\label{simpleMatchAlgorithm}
\KwIn {$p \in M$, $t \in T$, $v_p \colon X \rightharpoonup T$}

\If {$p \in X$ \KwAnd $v_p~p = \bot$} {
	$(v_p~p) \leftarrow t$\;
	\Return {$(\mathrm{true}, v_p)$}
}
\ElseIf {$p \in X$ \KwAnd $v_p~p \neq \bot$}{
	\Return {$(v_p~p = t, v_p)$}
}
\ElseIf {$p \in C \setminus X$} {
	\Return {$(p = t, v_p)$}
}
\ElseIf {$p = (f, \elems p 0 {m-1})$ \KwAnd $t = (f, \elems t 0 {n-1})$}{
	\For {$k \in \{0, \dots, {n-1}\}$}{
		$(\mathit{success}_k, v_p) \leftarrow \mathrm{simpleMatchAlgorithm}(m_k, t_k, v_p)$\;
		\If {$\mathrm{not}~\mathit{success}_k$}{
			\Return {$(\mathrm{false}, v_p)$}
		}
	}
	\Return {$(\mathrm{true}, v_p)$}  
}
\Else {
	\Return {$(\mathrm{false}, v_p)$}  
}
\end{algorithm}


Wenn das Match streng definiert ist, also der Unterschied zwischen einem Muster $p$ und einem Literal $t$ für die Existenz eines Matches $v_p$ aussschließlich darin bestehen darf, dass Teilterme von $t$ in $p$ durch eine Mustervariable repräsentiert werden, ist ein einfacher Matchalgorithmus fast trivial. Auf der Idee von $\mathrm{simpleMatchAlgorithm}$ basieren allerdings auch die späteren Algorithmen dieses Kapitels. Diese ist, dass mit einer Tiefensuche, die parrallel durch Muster und Literal läuft, nach einem Unterschied zwischen beiden gesucht wird. Mustervariablen funktionieren dabei als Wildcard, wenn eine identische Mustervariable in der Tiefensuche vorher noch nicht gefunden wurde. Andernfalls vergleichen sie identisch zu dem Teilbaum, der mit dem ersten Vorkommen der Mustervariable verglichen wurde. Die Aufgabe diese vorher begegneten Teilbäume zu speichern übernimmt $v_p$, was erklärt, warum $v_p$ auch als Parameter für Algorithmus \ref{simpleMatchAlgorithm} notwendig ist. Ist das gesamte Muster durchlaufen worden ohne einen strukturellen Unterschied zum Literal zu finden, ist $v_p$ das resultierende Match.\\

\begin{lemma}~\\
Die Laufzeit von Algorithmus \ref{simpleMatchAlgorithmShell} ist linear abhängig von der Anzahl der Funktionssymbole und Konstantensymbole des Literals.
\end{lemma}

\textbf{Beweis}.\\
Gibt es ein Match, wird jedes Funktionssymbol und Konstantensymbol des Literals höchstens ein mal in simpleMatchAlgorithm abgelaufen. Wird eine Funktionsanwendung $t$ im Literal parrallel zu einer Mustervariable $\mathbf x$ im Muster abgelaufen, bleiben die Nachkommen von $t$ unbesucht wenn $\mathbf x$ noch nicht gematcht wurde. Andernfalls wird jeder Nachkomme von $t$ höchstens ein mal abgelaufen, um Gleichheit zu $v_p~\mathbf x$ zu testen.
Gibt es kein Match wird das Literal so lange indentisch zum anderen Fall abgelaufen, bis ein struktureller Unterschied festgestellt wurde. Dann bricht der Algorithmus ab.
\hfill $\square$\\


\begin{definition}~\\
Die Instanz einer Mustervariable $\mathbf x$ wird als \emph{bindend}  bezeichnet, wenn sie in einer Tiefensuche durch das gesamte Muster als erste Instanz abgelaufen wird. Da Algorithmus \ref{simpleMatchAlgorithm} das Muster in einer Tiefensuche abläuft, ist die Bedingung $p \in X$ \KwAnd $v_p~p = \bot$ in der ersten Zeile damit genau dann wahr, wenn $p$ bindend ist\footnote{Der Begriff \emph{bindend} ist so zu verstehen, dass $\mathbf x$ nach Ablauf der ersten Instanz in Algorithmus \ref{simpleMatchAlgorithm} einen festen Wert $v_p~\mathbf x$ hat, also für den spätere Teile des Musters an diesen Wert gebunden ist.}. Weitere Instanzen von $\mathbf x$ im selben Muster werden als \emph{gebunden} bezeichnet.
\end{definition}


%.........................................................................
%.........................................................................
%.........................................................................
\section{Multi-Mustervariablen} \label{subsecMulti}

Von Anfang an werden Funktionssymbole in dieser Arbeit als möglicherweise variadisch definiert. Das ist in sofern ein Problem, als Muster bisher immer nur eine feste Anzahl an Parametern für jede Funktionsanwendung angeben können. Ist ein variadisches Funtionssymbol zudem assoziativ, ließe sich dieses Problem prinzipiell beheben, wenn Assoziativität im Matchalgorithmus berücksichtigt würde. Das Muster $\tilde p = (f, \mathbf x, \mathbf y)$ würde für ein assoziatives Funktionssymbol $f$ dann auch Literale wie $\tilde t = (f, a, b, c, d)$ matchen, mit verschiedenen Optionen für $v_p$, etwa $v_p~\mathbf x = (f, a, b)$ und $v_p~\mathbf y = (f, c, d)$. Ist auch die leere Funktionsanwendung $(f)$ von $f$ erlaubt \footnote{Das ergibt dann Sinn, wenn $f$ ein neutrales Element $e \in T$ besitzt, da $(f, as..., (f), bs...)$ mit $\mathrm{normalize}$ zu $(f, as..., bs...) = (f, as..., e, bs...)$ umgeformt wird. Im Folgenden wird von der Existenz eines Neutralen Elementes ausgegangen.}, gäbe es fünf verschiedene Matches $v_p$ für $\paren*{\tilde p, \tilde t}$ mit nicht-kommutativem $f$.

\begin{lemma}~\\
Das Muster $p = (f, \elems {\mathbf x} 1 m)$ hat mit dem Literal $t = (f, \elems a 1 n)$ genau ${m + n - 1}\choose n$ mögliche Matches, wenn $f$ assoziativ aber nicht kommutativ ist $(1)$. Ist $f$ assoziativ und kommutativ gibt es $m^n$ mögliche Matches $(2)$.\\
\end{lemma}

\textbf{Beweis}.\\
$(1)$: Es gibt $m$ möglicherweise leere Abschnitte in den $n$ Parametern von $t$, welche jeweils eine Mustervariable $\mathbf x_i$ matchen. Stellt man eine Abschnittsgrenze mit einem Strich $~|~$ und ein Parameter von $t$ mit einem Stern $~*~$ dar, kann die Aufteilung der Parameter von $t$ über ein String aus $m - 1$ Strichen und $n$ Sternen dargestellt werden. 
Als Beispiel ist $~**|**~$ der String zur Aufteilung von $\tilde t$ aus dem Anfang des Abschnittes zum beschriebenen Match $v_p$.
Es gibt ${m + n - 1}\choose n$ Möglichkeiten die $n$ Sterne auf die ${m + n - 1}$ möglichen Plätze zu verteilen.\\

$(2)$: Jeder der $n$ Parameter von $t$ kann unabhängig der restlichen Parametern zu einer der $m$ Mustervariablen gematcht werden. Insgesamt ergeben sich so $m^n$ Kombinationen.
\hfill $\square$\\

Schon für nicht-kommutative aber assoziative Funktionssymbole $f$ gibt es somit Muster $p$ mit einer Anzahl möglicher Matches, die exponentiell mit der Größe des Literals steigt. Ist ein solches Muster $p$ Teil eines größeren Musters $p'$ und kommen Mustervariablen von $p$ auch in anderen Teilen von $p'$ vor, so ist nicht direkt ersichtlich, wie ein Algorithmus aussehen würde, der in $P$ liegt und bestimmen kann, dass es kein Match für $p'$ mit einem entsprechenden Literal gibt, bzw. das Match findet. Die Existenz eines solchen Algorithmus ist unwarscheinlich: Benanav hat 1987 gezeigt, dass das Problem NP-vollständig ist \cite{NPHardMatching}.
Von dem perfekten Matchalgorithmus wird aus diesem Grund abgesehen. Für viele Spezialfälle sind allerdings bessere Algorithmen möglich. Eine wichtige Klasse solcher Spezialfälle ist die, wo von vorne herein klar ist, welche Mustervariable möglicherweise mehrere Parameter des Literals matchen soll. Würde man etwa bei der Ersetzung der ersten Binomischen Formel eine weitere Mustervariable $\mathbf c$ hinzufügen, um die Binomische Formel auch in einer Summe mit mehr als drei Summanden zu erkennen, kann die Ersetzungregel geschrieben werden als
$$(\texttt{sum}, (\texttt{pow}, \mathbf a, 2), (\texttt{prod}, 2, \mathbf a, \mathbf b), (\texttt{pow}, \mathbf b, 2), \mathbf c) \mapsto (\texttt{sum}, (\texttt{pow}, (\texttt{sum}, \mathbf a, \mathbf b), 2), \mathbf c).$$
$\mathbf c$ ist damit vom Autor des Musters ausschließlich dazu gedacht überbleibende Summanden \glqq aufzusaugen\grqq{}. Dieser Gedanke bleibt aber bisher dem Algorithmus verborgen.
Die in dieser Arbeit gewählte Lösung zur Beschreibung von beliebig vielen Parametern in einem Muster ist im Prinzip schon in Kapitel \ref{secErsteNormalform} eingeführt worden. Die Schreibweise $(f, ts...)$ als kompakte Alternative zu $(f, t_1, \dots, t_n)$ hat viele der zur Beschreibung von Assoziativität gewünschten Eigenschaften. Ferner können so auch Muster mit nicht assoziativen variadischen Funktionssymbolen dargestellt werden. Eine \textit{Multi-Mustervariable} der Form $\mathbf{xs...}$ kann also nicht nur genau einen Parameter in einer Funktionsanwendung matchen, sondern beliebig viele, auch keinen. Um den Matchalgorithmus nicht zu kompliziert zu gestalten, darf jede Multi-Mustervariable auf der linken Seite einer Ersetzungsregel nur höchstens ein Mal vorkommen\footnote{Das macht zudem mehrere Multi-Mustervariablen in der selben Funktionsanwendung eines kommutativen Funktionssymbols auf der linken Seite einer Ersetzungsregel überflüssig. Diese Konstellation ist dementsprechend im Folgenden nicht berücksichtigt.}. Die rigorose Beschreibung des Konzeptes gestaltet sich allerdings mit der bisher eingeführten Ideen schwierig, da eine Multi-Mustervariable nur Teil einer Funktionsanwendung ist und damit auch alleine keinen vollständigen Term repräsentiert. Konnte eine Matchfunktion $v_p \colon X \rightarrow T$ vorher einfach auf die Menge aller Terme abbilden, wäre dies nach Hinzufügen der Multi-Mustervariablen nicht mehr möglich. Entsprechend umständlicher würde auch die Beschreibung der Auswertung eines Musters werden. \\

Formal wird die Multi-Mustervariable damit nicht als echtes neues Symbol in die Menge der Muster aufgenommen, sondern ist lediglich eine vereinfachende Schreibweise, die wie auch vorher immer für eine beliebige Anzahl an Teiltermen steht, in diesem Fall Mustervariablen. Ein Muster mit einer Multi-Mustervariable $\mathbf{xs...}$ repräsentiert also formal unendlich viele konkrete Muster mit konkreten Mustervariablen $\mathbf{x_i}$:
\begin{equation*}
	\begin{split}
			(f, \mathbf{ts...}) = \{&(f), \\
			&(f, \mathbf{x_1}),\\
			&(f, \mathbf{x_1}, \mathbf{x_2}), \\
			&(f, \mathbf{x_1}, \mathbf{x_2}, \mathbf{x_3}), \\
			&\dots \}    		
	\end{split}
\end{equation*}
Für die folgenden Algorithmen dieses Kapitels, sowie der echten Umsetzung, ist es allerdings nicht praktikabel diese Definition anzuwenden. Mit der Restriktion, dass jede Multi-Matchvariable auf der linken Seite einer Ersetzungsregel höchstens ein Mal vorkommen darf, ist eine sehr einfache Verwaltung möglich. Für Funktionsanwendungen kommutativer Funktionssymbole in einem Muster muss lediglich zwischen \emph{enthält eine Multi-Matchvariable} und \emph{enthält keine Multi-Matchvariable} unterschieden werden. Multi-Matchvariablen in Funktionsanwendungen nicht-kommutativer Funktionssymbole haben allerdings eine eindeutige Position. Im Folgenden werden aber auch hier keine weiteren Parameter für Multi-Matchvariablen hinzugefügt. Alternativ wird für jeden tatsächlichen Term in den Parametern einer solchen Funktionsanwendung festgehalten, ob er Nachfolger einer Multi-Matchvariable ist und weiter, ob an dem letzten Parameter noch eine Multi-Matchvariable anschließt. 
Die Ersetzungsregel für die erste Binomische Formel anwendbar auf Summen beliebiger Länge wird demgemäß  geschrieben als:
$$(\texttt{sum}, (\texttt{pow}, \mathbf a, 2), (\texttt{prod}, 2, \mathbf a, \mathbf b), (\texttt{pow}, \mathbf b, 2), \mathbf{cs...}) \mapsto (\texttt{sum}, (\texttt{pow}, (\texttt{sum}, \mathbf a, \mathbf b), 2), \mathbf{cs...}).$$
Die Summe der linken Seite setzt sich für die folgenden Algorithmen dieses Kapitels dennoch nur aus drei Summanden zusammen. Die syntaktisch als Parameter geschriebenen $\mathbf{cs...}$ kommen hier in der linken Seite der Regel nur als Wahrheitswert vor, denn es gilt \glqq Die Summe \emph{enthält eine Multi-Matchvariable}\grqq{}. Lediglich auf der rechten Seite ist relevant, um welche Multi-Matchvariable es sich handelt, sollte es mehrere geben. Dieses Kapitel befasst sich allerdings ausschließlich mit der linken Seite einer Regel.



%.........................................................................
%.........................................................................
%.........................................................................
\section{Kommutative Muster} \label{subsecACMuster}

Die Algorithmen \ref{findMatch}, \ref{rematch}, \ref{findPermutation}, \ref{findDilation} und \ref{findIdentic} bilden zusammen die Grundlage des finalen Matchalgorithmus dieser Arbeit. Der Startpunkt einer Matchsuche ist der Aufruf von $\mathrm{findMatch}$. Hier wird allerdings im Kontrast zu $\mathrm{simpleMatchAlgorithm}$ nicht direkt ein Rekursionsaufruf durchgeführt, sondern abhändig von der Form der vorgefundenen Funktionsanwendung eine entsprechende Strategie für die Suche eines Matches gewählt. Die Algorithmen, die die entsprechenden Strategien implementieren sind $\mathrm{findPermutation}$, $\mathrm{findDilation}$ und $\mathrm{findIdentic}$. Alle hier vorgestellten Strategien nutzen dabei Backtracking um die verschiedenen Möglichkeiten zu testen. Sollte dabei die Notwendigkeit auftreten, für einen bereits gematchten Teil des Musters ein neues Match mit dem selben Literal zu finden, wird in allen drei Strategien $\mathrm{rematch}$ aufgerufen. Dieser Algorithmus ist ähnlich zu $\mathrm{findMatch}$, erwartet dementsprechend allerdings, dass das übergebende Muster $p$ bereits mit dem übergebenen Literal $t$ gematcht ist. Die eigentliche Arbeit wird bei $\mathrm{rematch}$ allerdings erneut an die Suchstrategien abgegeben. Da der Startpunkt dort allerdings davon abhängig ist, ob bereits eine bestimmte Zuordnung der Parameter als erfolgreich matchend festgehalten ist oder nicht, wird diese Information als letztes Argument jeder Strategie mit übergeben.


Im Grundaufbau funktionieren alle Strategien gleich. Die Parameter $\elems p 0 {m-1}$ des Musters $p$ werden in der vorliegenden Reihenfolge mit den Parametern $\elems t 0 {n-1}$ des Literals $t$ gematcht. kann für den aktellen Parameter $p_i$ kein Match mehr gefunden werden, wird probiert die vorhergehenden Parameter $\elems p 0 {i-1}$ neu zu matchen, beginnend mit $p_{i-1}$. Mit welchen Parametern $t_k$ ein Match dabei erlaubt ist, ist nach Strategie unterschiedlich. Am stärksten eingeschränkt ist $\mathrm{findIdentic}$. $p_i$ kann dort nur mit $t_k$ gematcht werden, wenn $k = i$ gilt\footnote{Algorithmus \ref{simpleMatchAlgorithm} hat ausschließlich auf diese Weise nach einem Match gesucht}. Das andere Extrem stellt $\mathrm{findPermutation}$ da. Hier kann jedes $p_i$ mit jedem $t_k$ gematcht werden, vorrausgesetzt $t_k$ ist noch nicht mit einem Parameter aus $\elems p 0 {i-1}$ gematcht. In der Freiheit dazwischen steht $\mathrm{findDilation}$, welche die Reihenfolge der $p_i$ untereinander gleich halten muss, jedoch eine Lücke beliebiger Länge zwischen $p_{i-1}$ und $p_i$ erlaubt, sofern im Muster an dieser Stelle eine Multi-Matchvariable steht\footnote{Wie in Abschnitt \ref{subsecMulti} erörtert, treten diese hier nicht als echte Parameter auf.}.

\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{findMatch} \colon M \times T \rightarrow \mathit{Bool}$}\label{findMatch}
\KwIn {$p \in M$, $t \in T$}

\If {$p \in X$ \KwAnd $p$ bindend}{
	merke: $v_p~p = t$\;
	\Return {$\mathrm{true}$}
}
\ElseIf {$p \in X$ \KwAnd $p$ gebunden}{
	\Return {$v_p~p = t$}
}
\ElseIf {$p \in C \setminus X$} {
	\Return {$p = t$}
}
\ElseIf {$p = (f, \elems p 0 {m-1})$ \KwAnd $t = (f, \elems t 0 {n-1})$}{
	\If {$u~f$ kommutativ} {
		\Return {$\mathrm{findPermutation}(p, t, \mathrm{false})$}
	}
	\ElseIf {$\elems t 1 n$ enthalten Multi-Matchvariablen} {
		\Return {$\mathrm{findDilation}(p, t, \mathrm{false})$}
	}
	\ElseIf {$m = n$} {
		\Return {$\mathrm{findIdentic}(p, t, \mathrm{false})$}
	}
}
\Return{$\mathrm{false}$}  
\end{algorithm}

\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{rematch} \colon M \times T \rightarrow \mathit{Bool}$}\label{rematch}
\KwIn {$p \in M$, $t \in T$}
\If {$p = (f, \elems p 0 {m-1})$ \KwAnd $t = (f, \elems t 0 {n-1})$} {
	\If {$u~f$ kommutativ} {
		\Return {$\mathrm{findPermutation}(p, t, \mathrm{true})$}
	}
	\ElseIf {$\elems t 1 n$ enthalten Multi-Matchvariablen} {
		\Return {$\mathrm{findDilation}(p, t, \mathrm{true})$}
	}
	\ElseIf {$m = n$} {
		\Return {$\mathrm{findIdentic}(p, t, \mathrm{true})$}        
	}
}        
\Return {$\mathrm{false}$}  
\end{algorithm}

Abweichend von bisherigen Algorithmen wird von hier an im Pseudocode nicht mehr jede tatsächlich notwendige Information explizit übergeben. Als Beispiel muss $v_p$ nach wie vor von jedem Funktionsaufruf aktualisiert werden, ist aber im Pseudocode der Algorithmen \ref{findMatch}, \ref{findPermutation}, \ref{findDilation}, etc. nicht länger explizit in Parameterliste oder als Rückgabewert erwähnt.
Anstelle der konkreten Zuweisung eines Wertes zu einem Namen, dargestellt duch den Pfeil nach links \glqq $\leftarrow$\grqq{}, wird die Veränderung einer solchen nicht explizit erwähnten Datenstruktur nur mit dem Wort \glqq merke\grqq{} dargestellt.

\subsection{findMatch und rematch}
Algorithmus \ref{findMatch} ist in der Struktur ähnlich zu $\mathrm{simpleMatchAlgorithm}$. Neben dem Auslagern der Rekursionsaufrufe in die verschiedenen Matchstrategien, besteht ein Unterschied im Umgang mit Mustervariablen. Für $\mathrm{simpleMatchAlgorithm}$ wird getestet, ob der Funktionswert $v_p~\mathbf x$ für eine Mustervariable $\mathbf x$ bereits definiert ist, wenn $\mathbf x$ angetroffen wird und herausgefunden werden muss ob die Instanz bindend oder gebunden ist. Das reicht für $\mathrm{findMatch}$ nicht, da dieser Algorithmus auch funktionieren muss, wenn die verschiedenen Matchstrategien ein Backtracking beinhalten, d.h., $\mathrm{rematch}$ aufrufen.
Der Algorithmus $\mathrm{rematch}$ ist fast identisch zur unteren Hälfte von $\mathrm{findMatch}$, ruft die verschiedenen Matchstrategien allerdings mit $\mathrm{true}$ als letzen Parameter auf, was bedeutet, dass direkt zum Backtracking gesprungen wird.



\subsubsection {findIdentic}
\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{findIdentic} \colon M \times T \times \mathit{Bool} \rightarrow \mathit{Bool}$}\label{findIdentic}
\KwIn {$p = (f, \elems p 0 {n-1}) \in M$, $t = (f, \elems t 0 {n-1}) \in T$, $\mathit{starteGematcht} \in \mathit{Bool}$}
\Let {$i \leftarrow 0$}\;
\If {$\mathit{starteGematcht}$} {
	$i \leftarrow n$\;
	\Goto \texttt{\ref{backtrackRematchMuster}}\;
}
\Loop {} {
	\nlset{matche $p_i$} \label{backtrackMatchMuster}
	\While {$\mathrm{findMatch}(p_i, t_i)$} {
		$i \leftarrow i + 1$\;
		\lIf {i = n} {\Return {$\mathrm{true}$}}    
	}
	\nlset{zurück} \label{backtrackRematchMuster}
	\DoWhile {$\mathrm{not}$ $\mathrm{rematch}(p_i, t_i)$} { 
		\lIf {i = 0} {\Return {$\mathrm{false}$}}
		$i \leftarrow i - 1$\;
	}    
	$i \leftarrow i + 1$\;
}
\end{algorithm}


Als Strategie mit den wenigsten Freiheiten ist die Umsetzung von $\mathrm{findIdentic}$ die kürzeste. Die Laufvariable $i$ steht gleichzeitig als Index für die Parameter von Muster und Literal. Wenn der Aufruf aus $\mathrm{findMatch}$ erfolgt, wird mit $i = 0$ gestartet und in Abschnitt \texttt{\ref{backtrackMatchMuster}} versucht für alle $i$ bis $n-1$ $p_i$ mit $t_i$ zu matchen. Sollte das  für ein $i$ fehlschlagen, besteht die Hoffnung, dass einer der Parameter $p_j \in \{\elems p 0 {i-1}\}$ anders als bisher mit $t_j$ gematcht werden kann, wodurch dann das Match von $p_i$ mit $t_i$ ermöglicht wird. Gefunden wird $p_j$ in Abschnitt \texttt{\ref{backtrackRematchMuster}}. 
Soll das gesamte Muster neu gematcht werden, startet $\mathrm{findIdentic}$ bei einem Aufruf durch $\mathrm{rematch}$ deswegen bei \texttt{\ref{backtrackRematchMuster}} und $i = n$.

\begin{lemma}\label{lemKomplexitaetFindPermutation}~\\
Die Laufzeitkomplexität von Algorithmus \ref{findIdentic} bei der Suche eines Matches für ein Muster $p = (f, \elems {\mathbf x} 0 {n-1})$ mit einem Literal $t = (f, \elems t 0 {n-1})$ ist in $\mathcal O(n)$, wenn jeder Parameter $t_i$ von $t$ nur $\mathcal O(1)$ Konstantensymbole und Funktionssymbole besitzt.
\end{lemma}

\textbf{Beweis}.\\
Der Ausdruck $\mathrm{not}$ $\mathrm{rematch}(pi , ti)$ ist für kein $i$ wahr, da $\mathrm{rematch}$ für Mustervariablen immer $\mathrm{false}$ zurückgibt. Die äußere Schleife wird also nur exakt ein Mal durchlaufen. Sowohl ein Durchlauf der \textbf{while}-Schleife, als auch ein Durchlauf der \textbf{do-while}-Schleife ist in $\mathcal O(1)$, da jedes $t_i$ nur $\mathcal O(1)$ Teilterme hat, bzw. $\mathrm{rematch}(pi , ti)$ für Mustervariblen $p_i$ direkt $\mathrm{false}$ zurückgibt. Entweder wird der Abschnitt \texttt{\ref{backtrackMatchMuster}} exakt $n$ Mal abgelaufen und $\mathrm{true}$ zurückgegeben oder $n' < n$ Mal abgelaufen, woraufhin auch Abschnitt \texttt{\ref{backtrackRematchMuster}} $n'$ Mal abgelaufen wird, bis $\mathrm{false}$ zurückgegeben wird. 
\hfill $\square$\\



\subsubsection {findPermutation}
\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{findPermutation} \colon M \times T \times \mathit{Bool} \rightarrow \mathit{Bool}$}\label{findPermutation}
\KwIn {$p = (f, \elems p 0 {m-1}) \in M$, $t = (f, \elems t 0 {n-1}) \in T$, $\mathit{starteGematcht} \in \mathit{Bool}$}
\Let {$i \leftarrow 0$, $k \leftarrow 0$}\;
\If {$\mathit{starteGematcht}$} {
	$i \leftarrow m$\;
	\Goto \texttt{\ref{permutationRematchMuster}}\;
}
 \If {$m > n$} {
	\Return {$\mathrm{false}$}
 }
 \nlset{matche $p_i$}\label{PermutationHauptschleifenbeginn}
 \While {$i < m$} {
	\While {$k < n$} {
		\If {$t_k$ ist mit keinem Parameter von $p$ gematcht} {
			\If {$\mathrm{findMatch}(p_i, t_k)$} {
				\Goto \texttt{\ref{permutationNaechstesMuster}}\;
			}
		}
		$k \leftarrow k + 1$\;
	}
	\nlset{zurück}\label{permutationRematchMuster}
	\If {$i = 0$} {
		\Return {$\mathrm{false}$}
	}
	$i \leftarrow i - 1$\;
	{$k \leftarrow k'$ aus \glqq $p_{i}$ ist mit $t_{k'}$ gematcht\grqq{}}\;
	\If {not $\mathrm{rematch}(p_{i}, t_{k})$} {
		merke: $p_{i}$ ist nicht mehr mit $t_{k}$ gematcht\;
		$k \leftarrow k + 1$\;
		\Goto \texttt{\ref{PermutationHauptschleifenbeginn}}\;
	} 
	\nlset{weiter}\label{permutationNaechstesMuster}
	merke: $p_i$ ist mit $t_k$ gematcht\;
	$i \leftarrow i + 1$\;
	$k \leftarrow 0$\;    
 }
 \Return {$p$ enthält eine Multi-Matchvariable \KwOr alle $t_k$ wurden gematcht}
\end{algorithm}

Algorithmus \ref{findPermutation} probiert das Muster einer kommutativen Funktionsanwendung $p$ auf ein Literal $t$ der gleichen Form zu matchen. Die beiden Laufvariablen $i$ und $k$ sind Index für die Muster Parameter $\elems p 0 {m-1}$, bzw. der Parameter des Literals $\elems t 0 {n-1}$. Für die Suche eines Matches wird zuerst versucht $p_0$ mit $t_0$ zu matchen. Schlägt das fehl, wird $k$ hochgezählt, bis $p_0$ ein $t_k$ matchen kann oder jedes $t_k$ getestet wurde. Im erfolglosen Fall wird die Suche beendet, da für $p_0$ alle verfügbaren Freiheitsgerade getestet wurden. Wurde $p_0$ erfolgreich mit $t_k$ gematcht, wiederholt sich der Prozess für $p_1$, mit der Ausname, dass $t_k$ jetzt nicht mehr als Matchkandidat zur Verfügung steht. Wird ein Parameter gefunden, der $p_1$ matcht, wird $i = 3$ gesetzt und der Prozess wiederholt sich für $p_3$. Falls die Suche für $p_1$ in dem Durchlauf allerdings erfolglos war, heißt es allerdings nicht, dass kein Match von $p$ und $t$ möglich ist. Es besteht die Option, dass $p_0$ mit $t_k$ noch auf eine andere Weise als die bisherige gematcht werden kann. Beinhaltet $p_1$ Mustervariablen, die in $p_0$ bindend vorkommen, eröffnet ein ändern der Bindung möglicherweise neue Matchmöglichkeiten für $p_1$. Aus dem Grund wird im Abschnitt \texttt{\ref{permutationRematchMuster}} zuerst versucht $p_0$ mit $t_k$ zu rematchen. Sollte das fehlschlagen, ist es möglich, dass $p_0$ noch mit Parametern von $t$ gematcht werden kann, die nach $t_k$ aufgelistet sind, was wiederum $p_1$ erlauben würde, ein Match mit $t_k$ zu testen. Auch diese Option wird ausprobiert.
Wurde für alle $p_i$ ein Match gefunden, so ist ganz $p$ mit ganz $t$ gematcht, falls gleichzeitig alle $t_k$ gematcht sind oder $p$ eine Multi-Matchvariable enthält. Sollte keiner der beiden Fälle eintreten, ist an dieser Stelle kein Match von $p$ und $t$ möglich. 


\begin{lemma}\label{lemKomplexitaetFindPermutation}~\\
Die Laufzeitkomplexität von Algorithmus \ref{findPermutation} bei der Suche eines Matches für ein Muster $p = (f, \elems {\mathbf x} 0 {m-1})$ mit einem Literal $t = (f, \elems t 0 {n-1})$ ist in $\mathcal O(n^m)$, wenn jeder Parameter $t_k$ von $t$ nur $\mathcal O(1)$ Konstantensymbole und Funktionssymbole besitzt.
\end{lemma}

\textbf{Beweis}.\\
Der Beweis erfolgt als Induktion über $m$.
Für den Induktionsanfang mit $m = 1$ muss $\mathbf x_0$ höchstens mit allen $n$ Parametern des Literals verglichen werden. Unabhängig davon, ob die Instanz von $\mathbf x_0$ bindend oder gebunden ist, terminiert $\mathrm{findMatch}(\mathbf x_0, t_k)$ in $\mathcal O(1)$, da alle $t_k$ in ihrer Größe beschränkt sind. \\
Im allgemeinen Fall kann die Anwendung von $\mathrm{findPermutation}$ mit $p$ und $t$ auf höchstens $m$ Anwendungen des Algorithmus mit Mustergröße $m-1$ zurückgeführt werden. Erneut kann $\mathbf x_0$ potenziell mit jedem $t_k$ matchen. Das Match mit $t_k$ erfolgt wie im Indunktionsanfang beschrieben in $\mathcal O (1)$. Die anschließende Suche nach Matches für $x_i$ mit $i > 0$ ist in der Komplexität äquivalent zu einem neuen Aufruf von $\mathrm{findPermutation}$ mit dem Muster $p' = (f, \elems {\mathbf x} 1 {m-1})$ und dem Literal $t' = (f, \elems t 0 {k-1}, t_k', \elems t {k+1} {n-1})$, wobei $t_k'$ ein spezieller Wert ist, mit dem ein Match zu jedem Muster in $\mathcal O (1)$ abgelehnt wird \footnote{Der Wert von $t_k'$ ist sonst nicht notwendig, da in Bereich \texttt{\ref{PermutationHauptschleifenbeginn}} durch die if-Abfrage der problematische Matchversuch mit $t_k$ umgangen wird.}. Gibt dieser Aufruf $\mathrm{false}$ zurück, gibt auch $\mathrm{rematch}(\mathbf x_0, t_k)$ in $\mathcal O (1)$ $\mathrm{false}$ zurück. Der Übergang von $t_k$ zu $t_{k-1}$ erfolgt ebenfalls in $\mathcal O (1)$. Für jedes der bis zu $n$ Matches von $\mathbf x_0$ mit einem $t_k$ treten damit Laufzeitkosten von $\mathcal O (1)$ außerhalb der Rekursion auf. Jeder der $n$ Rekursionsaufrufe hat nach Induktionshypothese eine Laufzeit in $\mathcal O (n^{m-1})$. Insgesamt ergibt sich so also eine Laufzeit in $n \cdot \mathcal O (1) \cdot \mathcal O (n^{m-1}) = \mathcal O (n^m)$.
\hfill $\square$\\


\subsubsection {findDilation}
\begin{algorithm}
\DontPrintSemicolon
\caption{$\mathrm{findDilation} \colon M \times T \times \mathit{Bool} \rightarrow \mathit{Bool}$}\label{findDilation}
\KwIn {$p = (f, \elems p 0 {m-1}) \in M$, $t = (f, \elems t 0 {n-1}) \in T$}
\Let $i \leftarrow 0$, $k \leftarrow 0$\;
\If {$\mathit{starteGematcht}$} {
	$i \leftarrow m$\;
	\Goto \texttt{\ref{dilationRematchLastNeedle}}\;
}
\If {$m = 0$} {
	\Return {$\mathrm{true}$}
}
\If {$n = 0$} {
	\Return {$\mathrm{false}$}
}
\nlset{matche $p_i$} \label{dilationMatchCurrentNeedle} 
\If {$k < n$} {
	\DoWhile {$p_i$ ist Nachfolger einer Multi-Matchvariable \KwAnd $k < n$} { 
		\If {$\mathrm{findMatch}(p_i, t_k)$} {
			\Goto \texttt{\ref{dilationPrepareNextNeedle}}\;
		}
		$k \leftarrow k + 1$\;
	}
}
\nlset{zurück} \label{dilationRematchLastNeedle} 
\While {$i > 0$} {
	$i \leftarrow i - 1$\;
	{$k \leftarrow k'$ aus \glqq $p_{i}$ ist mit $t_{k'}$ gematcht\grqq{}}\;
	\If {$\mathrm{rematch}(p_i, t_k)$} {
		\Goto \texttt{\ref{dilationPrepareNextNeedle}}\;
	}
	\ElseIf {$p_i$ ist Nachfolger einer Multi-Matchvariable} {
		$k \leftarrow k + 1$\;
	\Goto \texttt{\ref{dilationMatchCurrentNeedle}}\;
	}
}
\Return{$\mathrm{false}$}\;
\nlset{weiter} \label{dilationPrepareNextNeedle} 
merke: $p_i$ ist mit $t_k$ gematcht\;
$i \leftarrow i + 1$\;
$k \leftarrow k + 1$\;
\If {$i < m$} {
	\Goto \texttt{\ref{dilationMatchCurrentNeedle}}\;
}
\ElseIf {$k < n$ \KwAnd nach $p_{m-1}$ folgt keine Multi-Matchvariable} {
	\Goto \texttt{\ref{dilationRematchLastNeedle}}\;
}
\Return {$\mathrm{true}$}
\end{algorithm}


Algorithmus \ref{findDilation} teilt die Musterparameter $\elems p 0 {m-1}$ in Blöcke der Form $\elems p i j$ ein. Ein solcher Block muss Elementweise einen Block $\elems t k {k + j - i}$ der Parameter des Literals matchen. Die Aufteilung der Musterparameter in Blöcke ist dabei fest. Wenn zwischen $p_{i-1}$ und $p_{i}$ eine Multi-Matchvariable liegt, ist dort eine Blockgrenze. Aus dem Grund wird in \texttt{\ref{dilationMatchCurrentNeedle}} nur mehr als ein Schleifendurchlauf erlaubt, wenn $p_i$ einen neuen Block beginnt, $t_k$ also nicht durch den bereits gematchen Beginn des Blockes festgelegt ist. 
Konnte $p_i$ nicht gematcht werden, wird  $i$ im Bereich \texttt{\ref{dilationRematchLastNeedle}} so lange heruntergezählt, bis entweder $\mathrm{rematch}$ erfolgreich ist oder $p_i$ das erste Element des aktuellen Blocks ist. Besonderes Verhalten tritt erneut für $i = 0$ auf. War jeder Matchversuch für $p_0$ erfolglos, gibt es keine Möglichkeit mehr die Teilterme von $p$ so zu \glqq strecken\grqq{}\footnote{daher auch der Name $\mathrm{findDilation}$}, dass ein Match mit $t$ gefunden werden kann, ähnlich der Situation für $p_0$ in $\mathrm{findPermutation}$. Anders als bei $\mathrm{findPermutation}$ wird $k$ im Bereich \texttt{\ref{dilationPrepareNextNeedle}} allerdings hochgezählt, da $p_i$ nie ein Literal $t_k$ matchen darf, wenn $p_{i-1}$ bereits mit $t_l$ gematcht ist und $l > k$.


\begin{lemma}\label{lemKomplexitaetDilation}~\\
Die Laufzeitkomplexität von Algorithmus \ref{findDilation} bei der Suche eines Matches für ein Muster $p$  mit einem Literal $t = (f, \elems t 0 {n-1})$ ist in $\mathcal O(n^m)$, wenn jeder Parameter $t_k$ von $t$ nur $\mathcal O(1)$ Konstantensymbole und Funktionssymbole besitzt und $p$ eine Funktionsanwendung von $f$ auf $m$ Mustervariablen $\elems {\mathbf x} 0 {m-1}$, 
wobei jede Mustervariable $\mathbf x_i$ Nachfolger einer Multi-Matchvariable ist und auf $x_{m-1}$ eine Multi-Matchvariable folgt. Für $m = 3$ gilt also $p = (f, \mathbf{as...}, \mathbf x_0, \mathbf{bs...}, \mathbf x_1, \mathbf{cs...}, \mathbf x_2, \mathbf{ds...})$.
\end{lemma}

\textbf{Beweis}.\\
Sei $D(m, n)$ die asymptotische Laufzeit von Algorithmus \ref{findDilation}. Erneut wird ein Induktionsbeweis über $m$ beschrieben.
Mit $m = 1$ ist der Fall identisch zu dem Indunktionsanfang des Beweises von Lemma \ref{lemKomplexitaetFindPermutation}, es gilt $D(1, n) = \mathcal O(n)$. 

Für $m > 1$ wird $D(m, n)$ auf $D(m-1, n)$ zurückgeführt. Für jedes $k$ muss nach erfolgreichem Match von $\mathbf x_0$ mit $t_k$ versucht werden, die restlichen Mustervariablen $\elems {\mathbf x} 1 {m-1}$ in den restlichen Argumenten $\elems {t} {k+1} {n-1}$ des Literals $t$ zu matchen. Das entspricht einem erneuten Aufruf von $\mathrm{findDilation}$ mit neuem Muster $p'$ ohne $\mathbf x_0$ und neuem Liteal $t' = (f, \elems t {k+1}, {n-1})$.
Im rechenaufwändigsten Fall passiert das für jedes $k$.
$$D(m, n) = \sum_{k = 0}^{n-1} \paren*{\mathcal O(1) + D(m-1, n - k - 1)}$$
Trotz der vorgegebenden Reihenfolge der Matches von Musterparametern im Literal, folgt die selbe Komplexitätsabschätzung wie für $\mathrm{findPermutation}$.
\begin{equation*}
	\begin{split} 
		D(m, n) 
		&= \sum_{k = 0}^{n-1} \paren*{\mathcal O(1) + D(m-1, n - k - 1)}\\ 
		&< \sum_{k = 0}^{n-1} \paren*{\mathcal O(1) + D(m-1, n)}\\
		&= \mathcal O(n) + \mathcal O(n) \cdot D(m-1, n)\\
		&= \mathcal O(n) \cdot D(m-1, n)\\
		&= \mathcal O(n^m)
	\end{split}
\end{equation*}
\hfill $\square$\\


%.........................................................................
%.........................................................................
%.........................................................................
\section{Bessere Laufzeit für kommutative Muster} \label{subsecCMuster}

Benanav zeigte 1987, dass auch das Matchproblem mit einem kommutativen Funktionssymbol NP-vollständig ist \cite{NPHardMatching}. Dennoch kann die Laufzeit von $\mathrm{findPermutation}$ für bestimmte Arten von Mustern verbessert werden. In diesem Abschnitt wird das versucht, indem a priori ausgeschlossen wird, dass bestimmte Reihenfolgen von Musterparametern erfolgreich matchen können. Diese Reihenfolgen müssen dann im Algorithmus nicht mehr geprüft werden.
Vorraussetzung dafür wird sein, dass sowohl Muster als auch Literal mit $\mathrm{normalize}$ aus Kapitel \ref{secErsteNormalform} normalisiert werden. Insbesondere die Sortierung nach der Relation $<$ aus Definition \ref{defOrdnungKleiner} ist relevant.
Bestimmte Muster mit kommutativen Funktionssymbolen können mit dieser einfachen Maßname bereits in linearer Zeit mit einem Literal abgeglichen werden. Besteht ein Muster etwa aus der Anwendung eines komutativen Funktionssymbols $f$ auf $m$ Parameter $\elems p 1 m$ und sind die Parameter $p_i$ ausschließlich Funktionsanwendungen paarweise verschiedener Funktionssymbole, ist garantiert, dass die Parameter eines normalisierten Literals für ein Match in der selben Reihenfolge liegen müssen. Wenn auch alle Teilmuster $p_i$ dieser Struktur folgen, bzw. nicht kommutativ sind, wird ein Match zuverlässig bereits mit $\mathrm{findIdentic}$ (Algorithmus \ref{findIdentic}) gefunden\footnote{ohne Berücksichtigung von Matches, welche durch Assoziativität ermöglicht würden}. Das liegt daran, dass für alle $i, j \in \{1, \dots, m\}, i < j$ gilt, dass $p_i$ ausschließlich Literale matchen kann, die vor jedes Literal sortiert werden, welches mit $p_j$ gematcht werden könnte. Diese Idee der Ordnung von Mustern wird im Folgenden ausgeführt.


\begin{definition}~\\
Man sagt dass Muster $p_1$ ist \emph{stark kleiner} als das Muster $p_2$ oder $p_1 \prec p_2$, wenn für alle Matchfunktionen $v_p$ gilt, dass $\mathrm{lit}~(p_1, v_p) < \mathrm{lit}~(p_2, v_p)$. Gilt immer $\mathrm{lit}~(p_1, v_p) \leq \mathrm{lit}~(p_2, v_p)$, sagt man $p_1$ ist \emph{stark kleiner-gleich} als $p_2$ oder $p_1 \preceq p_2$.
\end{definition}

\begin{beispiel}~\\
Wenn $\texttt{sin} < \texttt{cos}$, gilt $p_1 \prec p_2$ für $p_1 = (\texttt{pow}, (\texttt{sin}, \mathbf x), 2)$ und $p_2 = (\texttt{pow}, (\texttt{cos}, \mathbf y), 2)$. Im Kontrast sind die Muster $\hat p_1 = (\texttt{pow}, \mathbf x, 2)$ und $\hat p_2 = (\texttt{pow}, \mathbf y, 3)$ zueinander nicht stark geordnet. Gezeigt werden kann das mit Literalten $t_1$, $t_2$ und $t_3$, wenn ${t_1 < t_2 < t_3}$ gilt, aber $\hat p_1$ sowohl $t_1$ als auch $t_3$ matchen kann und $\hat p_2$ das Literal $t_2$ matchen kann. Mit $1 < 2 < 3$ erfüllen $t_1 = (\texttt{pow}, 1, 2)$, $t_2 = (\texttt{pow}, 2, 3)$ und $t_3 = (\texttt{pow}, 3, 2)$ die Bedingungen.
\end{beispiel}

\begin{lemma}~\\
Sei $p$ ein Muster, welches mindestens die Mustervariable $\mathbf x$ enthält und $q$ ein Muster bestehend nur aus der Mustervariable $\mathbf y$.
Wenn es zwei Konstantensymbole $c_1 \neq c_2 \in C$ ohne Auswertung gibt, gilt weder $p \preceq q$, noch $q \preceq p$.
\end{lemma}

\textbf{Beweis}.\\
Sei $v_p^{(i)}$ eine Matchfunktion mit $v_p^{(i)}~\mathrm x = c_i$ und sonst von $i$ unabhängigen Funktionswerten. Die Literale $t_1 = \mathrm{lit}~(p, v_p^{(1)})$ und $t_2 = \mathrm{lit}~(p, v_p^{(2)})$ sind von einander verschieden und können beide sowohl $p$ als auch $q$ matchen. 
\hfill $\square$\\

Mit ähnlichen Argumenten 


Einfach zu sehen ist, dass nur sehr wenige Muster zueinander stark geordnet sind, wenn die allgemeinste Form des Matches erlaubt ist. Problematisch ist dabei vor allem $\mathrm{combine}$ (Algorithmus \ref{combine}) als Teil von $\mathrm{normalize}$. Dadurch wird es möglich Muster mit Funktionsanwendungen und Literale bestehend nur aus einer Konstanten zu matchen. Da es aufwändig ist überhaupt erst zu bestimmen, welche Muster Matches dieser Art erlauben, wird $\mathrm{normalize}$ hier abweichend von Kapitel \ref{secErsteNormalform} ohne $\mathrm{combine}$ angenommen. Nur Assoziativität und Kommutativität werden berücksichtigt.

\begin{lemma}~\\
Für folgende Formen von normalisierten Mustern $p$ und $q$ gilt $p \prec q$:
\begin{enumerate}
	\item{$p$ und $q$ enthalten keine Mustervariablen und $p < q$} \label{itemStarkKleiner1}
	
	\item{$p$ ist ein Konstantensymbol aber keine Mustervariable und $q$ ist eine Funktionsanwendung}  \label{itemStarkKleiner2}
	
	\item{$p$ und $q$ sind Funktionsanwendungen verschiedener Funktionssymbole $f$ und $g$ mit $f < g$}  \label{itemStarkKleiner3}
		
	\item{$p = (f, \elems p 0 {m-1})$ und $q = (f, \elems q 0 {n-1})$ sind Funktionsanwendungen des selben nicht-kommutativen Funktionssymbols $f$ und einer der folgenden Punkte trifft zu.
	\begin{enumerate}
		\item{$m < n$, $\forall j \in \{0, \dots, m-1\} \colon p_j = q_j$, $p$ hat keine Multi-Mustervariablen in seinen Argumenten und wenn $q$, dann erst nach $q_m$}
		\item{$\exists i < min\{n, m\} \colon p_i \prec q_i$, $\forall j \in \{0, \dots, i  - 1\} \colon p_j = q_j$ und weder $p$ noch $q$ haben Multi-Mustervariablen in ihren Argumenten vor $p_i$ bzw. $q_i$}
	\end{enumerate}
	} \label{itemStarkKleiner4}
	
	\item{$p = (f, \elems p 0 {m-1})$ und $q = (f, \elems q 0 {n-1})$ sind Funktionsanwendungen des selben kommutativen Funktionssymbols $f$, keine mit Multi-Mustervariablen unter ihren Argumenten und einer der folgenden Punkte trifft zu.
	\begin{enumerate}
		\item{$m < n$ und $\forall j \in \{0, \dots, m-1\} \colon p_j = q_j$}
		\item{$\forall i \in \{0, \dots, m-1\}, j \in \{0, \dots, n-1\} \colon p_i \prec q_j \lor p_i = q_j$}
	\end{enumerate}
	} \label{itemStarkKleiner5}
	
\end{enumerate}
\end{lemma}

\textbf{Beweis}~\\
In allen Fällen wird eine Mustervariable nur an Punkten erlaubt, die nicht zur Bestimmung der Ordnung von $p$ und $q$ unter der Relation $<$ beitragen, bzw die für kein Literal anstelle der Mustervariable die Ordnung der normalisierten Terme beeinflussen würden. Trivial ist das für Fall \ref{itemStarkKleiner1}.

Für die restlichen Fälle muss klar sein, dass ein Literal der Form $(f, xs...)$ auch nach Normalisierung diese Form behält. Die Reihenfolge der Argumente und damit auch ob $f$ kommutativ ist, spielen keine Rolle. Das Normalisieren mehrerer geschachtelter Anwendungen des selben assoziativen Funktionssymbols $f$ entfernt nie die äußerste Funktionsanwendung, die Struktur bleibt also auch so erhalten.
Fall \ref{itemStarkKleiner2} und Fall \ref{itemStarkKleiner3} sind ist damit bewiesen.

Mit der selben Argumentation bleibt $f$ auch in den Fällen \ref{itemStarkKleiner4} und \ref{itemStarkKleiner5} immer das äußerste Funktionssymbol erhalten. Da die Reihenfolge der Argumente in Fall \ref{itemStarkKleiner4} auch nach Auswertung der Musterinterpretation gleich bleibt, 

\hfill $\square$\\


Für folgende Formen von Mustern $p$ und $q$ gilt $p \preceq q$:
\begin{enumerate}
	\item{$p \prec q$}
	
	\item{$p = q$}
	
	\item{kontextabhängig, wenn $p = \mathbf x$ und $q = \mathbf y$ Mustervariablen sind und das gesamte Muster $r$, in dem sowohl $p$ als auch $q$ sich befinden \emph{symmetrisch} zu $\mathbf x$ und $\mathbf y$ ist. Symmetrisch ist $r$ dann, wenn $\mathbf x$ und $\mathbf y$ in ganz $r$ getauscht werden können um $r'$ zu erhalten und die normalisierte Form von $r'$ identisch zu $r$ ist.}
\end{enumerate}

\BFred{TODO: Beweise $p \preceq q$ in beschriebenen Fällen}

Beispiele für symmetrische Muster sind beide Seiten der ersten Binomischen Formel, wobei $\mathbf a$ symmetrisch zu $\mathbf b$ ist:
$$(\texttt{sum}, (\texttt{pow}, \mathbf a, 2), (\texttt{prod}, 2, \mathbf a, \mathbf b), (\texttt{pow}, \mathbf b, 2), \mathbf {c...}) \mapsto (\texttt{sum}, (\texttt{pow}, (\texttt{sum}, \mathbf a, \mathbf b), 2), \mathbf {c...})$$


\begin{lemma}\label{lemTransitivStark}~\\
$\prec$ und $\preceq$ sind transitiv $(1)$ und für $p, q, r \in M$  gilt $p \prec q \preceq r \implies p \prec r$ sowie $p \preceq q \prec r \implies p \prec r$ $(2)$. 
\end{lemma}

\textbf{Beweis}~\\
\BFred{TODO: beweise Lemma \ref{lemTransitivStark}}

\section{Value-Matchvariablen}
\BFred{Je nachdem, wie schnell ich den Rest zu einer Runden Gesamtstruktur bekomme, werde ich auch noch ein Wort über Muster verlieren, die den combine Teil von normalize zumindest teilweise berücksichtigen.}




\section{Termersetzungssystem} \label{subsecTermersetzungssystem}

Das Ziel dieses Abschnittes ist erneut die Normalisierung eines Terms. Im Unterschied zu Kapitel \ref{secErsteNormalform} werden die Ersetzungsregeln hier nicht im Algorithmus festgelegt, sondern erst als Parameter mit übergeben. 

Ist eine Ersetzungsregel auf das übergebende Literal $l = l^{(0)}$ oder ein Teil dessen anwendbar, so wird das Ergebnis der Ersetzung $l^{(1)}$ genannt. Auf dem selben Weg kann aus $l^{(1)}$ der Term $l^{(2)}$ erzeugt werden oder allgemeiner aus $l^{(i)}$ der Term $l^{(i+1)}$. Ist auf keinen Teil von $l^{(n)}$ mehr eine Regel anwendbar, wird $l^{(n)}$ als \emph{Normalform} von $l$ zu den übergebenden Ersetzungsregeln bezeichnet. 

Es ist möglich, dass ein Literal $l$ mit einer bestimmten Regelmenge mehr als nur eine Normalform besitzt. Eine einfache Regelmenge mit dieser Eigenschaft besteht aus zwei Regeln mit identischer linker Seite aber unterschiedlicher rechter Seite. Bestimmte Regeln können allerdings auch in Isolation mehrere Normalformen produzieren. Ein Beispiel ist die folgende Regel, welche $\mathbf x$ ausklammert:
$$(\texttt{sum}, \mathbf x, (\texttt{prod}, \mathbf x, \mathbf{ys...}), \mathbf{zs...}) 
\mapsto (\texttt{sum}, (\texttt{prod}, \mathbf x, (\texttt{sum}, 1, (\texttt{prod}, \mathbf{ys...})) , \mathbf{zs...})$$

Für das Literal $l = (\texttt{sum}, a, b, (\texttt{prod}, a, b))$ existiert sowohl die Normalform 
$$l' = (\texttt{sum}, b, (\texttt{prod}, a, (\texttt{sum}, 1, b))),$$ 
als auch 
$$l'' = (\texttt{sum}, a, (\texttt{prod}, b, (\texttt{sum}, 1, a))).$$

Das ist an dieser Stelle allerdings nicht neu: Algorithmus \ref{rematch} ($\mathrm{rematch}$) ist eine direkte Antwort auf Muster dieser Art. Die Fragestellung welche Mengen von Ersetzungsregeln eindeutige Normalformen unabhängig von der Reihenfolge ihrer Anwendung produzieren (\emph{konfluent} sind) ist im allgemeinen Fall nicht entscheidbar \cite{KonfluenzUnentscheidbar}.



\subsection{Strategien}
Eine besondere Eigenschaft der Normalisierung aus Kapitel \ref{secErsteNormalform} ist, dass die dadurch definierte Normalform eines Terms eindeutig ist. Gemeint ist damit, dass nicht nur die Funktion $\mathrm{normalize}$ deterministisch ist, sondern dass sie immer das selbe Ergebnis produziert, wie eine beliebige andere Strategie, die so lange die erläuterten drei Regeln Sortieren kommutativer Funktionsanwendungen, Zusammenfassen assoziativer Funktionsanwendungen und Auswerten auswertbarer Teile auf jeden Teilterm anwendet, bis keine Anwendung mehr zu einer Veränderung führt. Dies ist allerdings nicht für beliebige Mengen von Ersetzungsregeln der Fall. Das einfachste Gegenbeispiel sind zwei Regeln mit gleicher linker Seite aber unterschiedlicher rechter Seite.




Es gibt verschiedene Strategien in einem Term nach Teiltermen zu suchen, die transformiert werden können. Die Funktion $\mathrm{normalize}$ aus Kapitel \ref{secErsteNormalform} geht von innen nach außen, normalisiert also zuerst die Argumente einer Funktionsanwendung, bevor die Funktionsanwendung selbst normalisiert wird. Das hat den Vorteil, dass $\mathrm{normalize}$ ein sehr einfachen Aufbau besitzen kann, schließlich bleiben die Argumente in ihrer Normalform, wenn die umschließende Funktionsanwendung selbst normalisiert wird. Jede Funktionsanwendung eines zu normalisierenden Terms muss also nur ein Mal besucht werden.


Hier wird zuerst probiert Ersetzungsregeln auf das Literal als ganzes anzuwenden, dann, sollte das Literal eine Funktionsanwendung sein, auf seine Argumente. Der Vorteil besteht darin, dass mehr Terme normalisiert werden können \cite{EvalStrategien}. Der Nachteil besteht darin, dass der zur Umsetzung notwendige Algorithmus aufwendiger ist, da die Normalisierung eines Argumentes möglicherweise neue Transformationen für umschließende Terme eröffnet.

Ein grundlegendes Problem ist, dass die Normalform eines Literals für entsprechend gewählte Regelsätze von der gewählten Normalisierungsstrategie abhängt. 



















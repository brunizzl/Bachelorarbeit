
\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Entwicklung eines Termersetzungssystems für assoziative und kommutative Ausdrücke zum vereinfachen arithmetischer Terme\\ \textit{Version 0.0.1}}
\author{Bruno Borchardt}
\date{heute}

\usepackage{natbib}
\usepackage{graphicx}
\usepackage[ngerman]{babel}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsmath} %  \begin{cases}  Wert 1 & Bedingung 1 \\ Wert 2 & Bedingung 2 \\ \end{cases} 

\begin{document}

\maketitle

\tableofcontents

\clearpage
%\cleardoublepage <- für andere Dokumenttypen

\section{Einleitung}

Hier kommt hin, was halt in eine Einleitung soll:
\begin{itemize}
    \item was ist ein Termersetzungssystem?
    \item Einsatz von Termersetzungssystemen
    \begin{itemize}
        \item Beweisprüfer /Beweisassistenten
        \item Arithmetikausdrücke vereinfachen
        \item Optimierender Compiler
        \item bestimmt noch mehr
    \end{itemize}
    \item was soll die in dieser Arbeit umgesetzte Variante (gut) können?
    
\end{itemize}

\section{Datenstruktur}

Hier wird erläutert, wie meine konkrete Implementierung Terme speichert und verwaltet. Vielleicht werden auch ein paar grundlegene Algorithmen auf der Datenstruktur erklärt, sofern ich mein exaktes Vorgehen in keinem Paper wiederfinde.\\
Denkbare Algorithmen zum erklären:
\begin{itemize}
    \item Falten eines Terms
    \item Sortieren eines Terms / ordnen von Teiltermen
    \item exaktes Ausrechen von Teilbäumen ohne Variablen (und warum ich das mit dem Zusammenfassen von geschachtelten Summen und weiteren Sachen in einen Algorithmus zusammenwursten musste)
    \item Frage: aktuell parse ich einen String zum bauen eines Terms noch in $O(n^2)$. Das ist warscheinlich nicht optimal. Ergo würde ich diesen Teil wenn, dann eher am Rande erwähnen. Ist es für die Arbeit wichtig, das noch zu optimieren (unter der Vorraussetzung, dass die von mir gewählte Grammatik kontextfrei ist, was sie aber glaube ich ist)?
\end{itemize}

Mögliche Tangente: Meine Idee (und Umsetzung) einer Art Aufzählung (in C\texttt{++} und Co. as enum in der Sprache enthalten), die Hirarchien erlaubt und damit Basis eines (wie ich finde) relativ eleganten Typsystems für die einzelnen Arten von Termknoten darstellt. (Tangente der Tangente: Das native C\texttt{++} Typsystem mit Umsetzung von Polymorphie als Vererbung erschwert einem nicht nur das Speichern eines polymorphen Baums in einem Array, sondern verteilt auch den Code jedes Algorithmus über die verschiedenen Klassen, die die einzelnen Baumknotenarten modellieren. Deswegen habe ich mir was eingendes gebastelt)
~\\~

\clearpage

\subsection{Definitionen}
Eine Menge von Termen $T$ ist in dieser Arbeit in Abhängigkeit der Mengen $F$ und $\Sigma$, sowie der Funktion $\mathrm{rank} : F \rightarrow \mathbb{N}_0$, definiert. $$T(F, \Sigma) \coloneqq \Sigma \cup \{(f, t_1, \dots, t_n)~|~f\in F,~\mathrm{rank}(f) = n,~ t_i \in T(F, \Sigma)\}$$ \\
Elemente $f\in F$ werden \textit{Funktionssymbole} genannt, Elemente $s \in \Sigma$ werden \textit{Konstantensymbole} genannt. $(f, t_1, \dots, t_n) \in T \setminus \Sigma$ wird auch als $f(t_1, \dots, t_n)$ geschrieben und \textit{Funktionsanwendung} genannt. \\
Wichtig ist, dass auf der Definitionsebene nicht zwischen einem Konstantensymbol $s \in \Sigma$ unterschieden wird, dessen Wert eindeutig ist, etwa der konkreten Komplexen Zahl $s = 3-5i$ und einem Symbol, welches vom Kontext abhängt, etwa dem Zeichen $s = x$ (vorrausgesetzt $3-5i,~x \in \Sigma$). 

\subsubsection{Funktionsauswertung}
Ein Funktionssymbol ist in der allgemeinen Definition eines Terms noch keine Funktion, da die Abbildungsvorschrift, sowie Definitionsmenge und Bildmenge nicht definiert sind. Ein Funktionssymbol ohne diese Eigenschaften kann daher eher als Datenstruktur gesehen werden, etwa die Funktionsanwendung des Funktionssymbols $pair$ auf die zwei Parameter $a$ und $b$ als ein Paar: $pair(a, b)$.\\
Die erste Erweiterung der Funktionssymbolmenge zur Menge von Funktionen folgt mittels der $\mathrm{eval}$ Funktion.
$$\tilde{T}(F, \Sigma) \coloneqq \{(f, s_1, \dots, s_n)~|~f \in F,~\mathrm{rank}(f) = n,~s_i \in \Sigma\}$$
$$\mathrm{eval} \colon (\tilde{T} \rightarrow \Sigma) \times T \rightarrow \Sigma$$
$$\mathrm{eval}(v, t) = \begin{cases} 
            t &,~ t\in \Sigma \\
            v(s_1, \dots, s_n) &,~ t = (f, t_1, \dots , t_n), ~s_i = \mathrm{eval}(v, t_i)
            \end{cases}$$
Als Beispiel ist $\Sigma = \mathbb{N}$, $F = \{sum, product, power\}$ und $v$ definiert als
$$v(f, s_1, \dots, s_n) = \begin{cases}
s_1 + s_2 &,~ f = sum\\
s_1 \cdot s_2 &,~ f = product\\
(s_1)^{s_2} &,~ f = power\\
\end{cases}$$
Der Term $t = sum(3, product(2, 4))$ kann dann ausgewertet werden zu 
\begin{equation}
    \begin{split}
    \mathrm{eval}(v, t) &= \mathrm{eval}(v, sum(3, product(2, 4))) \\
    &= v(sum, \mathrm{eval}(v, 3), \mathrm{eval}(v, product(2, 4))) \\
    &= v(sum, 3, v(product, \mathrm{eval}(v, 2), \mathrm{eval}(v, 4))) \\
    &= v(sum, 3, v(product, 2, 4)) \\
    &= v(sum, 3, 8) \\
    &= 11 \\
    \end{split}
\end{equation}
\\
Nicht mehr ausreichend ist $\mathrm{eval}$, wenn auch Symbole unbekannten Wertes in $\Sigma$ aufgenommen werden oder wenn manche Funktionen nicht von bzw. nach $\Sigma$ abbilden. 

\subsubsection{Variadische Funktionen}









Eine Menge von Funktionssymbolen $F$ kann auf folgendem Weg um die Menge der Funktionen, die nur durch ihre Abbildungsvorschrift identifiziert sind, $L$ (auch \textit{Lambdas}) zu $F_L$ erweitert werden.
$$F_L \coloneqq F \cup L$$
$$L \coloneqq T(F_L, \Sigma \cup P)$$
$$P \cap \Sigma = \emptyset$$
$$pos \colon P \rightarrow \mathbb{N}_0, ~pos\text{ ist bijektiv}$$
Ein Element $x \in P$ wird Lambdaparameter genannt. Ein Lambdaparameter kann eindeutig über seinen Index in der Argumentliste identifiziert werden. So bildet $pos$ die Lambdaparameter $x$ und $y$ der Lambdadefinition $(\lambda x y. x+y)$ auf $pos(x) = 0$ und $pos(y) = 1$ ab. \\~\\~\\





Im folgenden wird hauptsächlich von zwei verschiedenen Arten von Termen gesprochen. Ein Literal ist das zu vereinfachende Objekt, während ein Musterterm genutzt wird um Muster im Literal zu erkennen und diese zu ersetzen. \\

Die Ausdrücke, die im Laufe dieser Arbeit vereinfacht werden sollen, werden im folgenden oft nur als Term bezeichnet. Ein solcher Term ist entweder eine Komplexe Zahl, ein nur über seinen Namen spezifiziertes Symbol (z.B. $pi$ oder $a$) oder ein Funktionsname in Kombination mit Funktionsparametern, welche selbst Terme sind (z.B. $sin(pi)$ oder $f(3)$). \\
Formal sind Terme wiefolgt definiert. Sei $\mathbb{C}$ der Körper der Komplexen Zahlen, $\Sigma^+$ die Menge aller Zeichenketten positiver Länge auf einer Zeichenmenge $\Sigma$ und sei $\text{rank} \colon \Sigma^+ \rightarrow \mathcal{P}(\mathbb{N}_0)$ die Funktion, die für den Name eines Funktionsterms angibt, welche Anzahlen von Aufrufparametern gültig sind. Im folgenden wird angenommen, dass ein Funktionsterm entweder eine eindeutige Stelligkeit hat oder eine beliebige Anzahl von Parametern zulässt, also 
$\text{rank} \colon \Sigma^+ \rightarrow \{\{n\}~|~n \in \mathbb{N}_0\} \cup \{\mathbb{N}_0\}$. 
Die Menge der Terme ist dann definiert als 
$$\mathbb{T} \coloneqq \mathbb{C} \cup \Sigma^+ \cup \mathbb{F}$$
$$\mathbb{F} \coloneqq \{(s, (t_1, \dots, t_n)) ~|~ s \in \Sigma^+ \land t_1, \dots, t_n \in \mathbb{T} \land n \in \text{rank}(s)\}$$
wobei $\mathbb{F}$ die Menge aller Funktionsterme darstellt. Als kompaktere Schreibweise kann ein Funktionsterm $(s, (t_1, \dots, t_n))$ auch $s(t_1, \dots, t_n)$ geschrieben werden.
Ein Symbol ist zudem unterscheidbar von einem Funktionsterm gleichen Namens und null Parametern, so ist $f$ ungleich $f()$.\\
Ein Funktionsterm hat wenig mit einer tatsächlichen Funktion zu tun. Weder Bildmenge noch Abbildungsvorschrift sind spezifiziert und auch die Definitionsmenge ist höchstens in ihrer Dimension eingeschränkt. Die passendere Interpretation des Funktionsterms ist daher die der Datenstruktur. Ein Beispiel ist die Darstellung einer Liste durch den Funktionsterm mit entspechendem Name, welcher eine beliebige Anzahl von Parametern übergeben bekommen kann, etwa $list()$ oder $list(3.0, pi, sin(3.0))$.
\\~\\


Sowohl der zu vereinfachende Term, als auch die Vereinfachungsregeln liegen im Programm als Baumstruktur vor. Die Knoten des Baumes haben jeweils einen der folgenden Typen:
\begin{enumerate}
    \item Komlexe Zahl \\
    Jeder bekannte Wert wird intern als komplexe Zahl mit Realteil und Imaginärteil als Fließkommazahl doppelter Präzesion aus der C\texttt{++} Standardbibliothek gespeichert.
    \item Variable \\
    Eine Variable besteht nur aus ihrem Name, welcher als Array von ASCII Buchstaben vorliegt.
    \item Bekannte Funktion \\
    Im Speicher des einzelnen Terms ist eine dem Programm bekannte Funktion als Array von Referenzen auf ihre Parameter gespeichert. Auf der Datenebene ist dabei nicht direkt erkennbar, ob die Funktion eine feste Anzahl von Parametern hat, wie etwa die Exponentialfunktion, oder variadisch ist, wie zum Beispiel die Summe. Dies erlaubt es, oft nicht zwischen beiden Arten differenzieren zu müssen.
    \item Unbekannte Funktion \\
    Funktionen, deren Name dem Programm nicht bekannt sind, speichern diesen pro Instanz, analog zur Variable. Vor dem Namensarray befindet sich ein Parameterarray, identisch zu dem der bekannten Funktion. Damit muss in vielen Fällen auch nicht zwischen bekannten Funktionen und unbekannten Funktionen unterschieden werden.
    \item Baum-Mustervariable \\
    Während die normale Variable vor allem im zu vereinfachenden Term erwartet wird, ist die Baum-Mustervariable das Symbol, welches in einem Muster für einen Teilbaum des zu vereinfachenden Terms steht. 
    \item Wert-Mustervariable \\
    Ähnlich wie die Baum-Mustervariable steht auch diese representativ für einen Teil des zu vereinfachenden Baums, hier allerdings nicht für einen beliebigen Teilbaum, sondern einen bekannten Zahlenwert. Die Separierung von der Baum- Mustervariable ist notwendig, um mehr Arten von Werten erkennen zu können, ohne extra ein System für das Überprüfen von Logikbedingungen einbauen zu müssen (wenn auch dieses mächtiger wäre).
\end{enumerate}
\clearpage


\section{Patternmatching}
Hier stelle ich vor, was für Matchingalgorithmen (für Bäume mit Knoten beliebigen Grades) ich in der Literatur finde. (Hoffentlich finde ich nicht den von mir genutzten, aber den als erster entdeckt zu haben halte ich für unwarscheinlich.)
Den von mir genutzen Algorithmus würde ich hier im Detail erklären und die Laufzeit analysieren. Spoiler: ich meine gelesen zu haben, dass das matchen von Mustern mit möglichen Mehrfachnennungen von Mustervariablen in variadischen Ausdrücken NP-schwer ist, aber vielleicht kann ich für praxisrelevante Teilmengen aller Musterterme bessere Worst-Case Laufzeiten erzielen. (Das optimieren meines Algorithmus ist noch im Gange).
\\~\\

\textbf{einfacher Matchingalgorithmus}


\section{Vereinfachen von Arithmetischen Termen}
Ich habe begonnen das Termersetzungssystem zu entwickeln, um Arithmetische Ausdrücke zu vereinfachen (etwa $a + 2 a \rightarrow 3 a$). Wie genau ich das umsetze, wird in diesem Abschnitt erläutert.
\\Während die Datenstruktur und der Matchingalgorithmus schon benutzbar sind, ist dieser Teil von mir bisher so gut wie gar nicht implementiert worden. Der grobe Plan ist aber folgender:
\begin{enumerate}
    \item Funktionen höherer Ordnung anwenden:
    \begin{itemize}
        \item ableiten (Prototyp dafür steht schon)
        \item vielleicht integrieren (soll für den allgemeinen Fall wohl schwer sein)
        \item vielleicht fouriertransformieren
        \item vielleicht laplacetransformieren
        \item ganz ganz ganz ganz vielleicht Differentialgleichungen lösen
    \end{itemize}
    \item Normalform herstellen:
    \begin{itemize}
        \item alles ausmultiplizieren ($a\cdot (b + c) \rightarrow a\cdot b + a\cdot c$)
        \item Vorzeichen aus ungeraden Funktionen herausziehen ($\sin(-x) \rightarrow -\sin(x)$)
        \item Vorzeichen in geraden Funktionen auf plus setzen ($\cos(-x) \rightarrow \cos(x)$)
        \item Überlegen, wie man das selbe für Fälle mit Summen im Argument definiert ($\cos(a - b)$ vs. $\cos(b - a)$)
        \item bekannte Faktoren aus Potenz ziehen ($(3 x)^2 \rightarrow 9 x^2$)
        \item \dots
    \end{itemize}
    \item Vereinfachen:
    \begin{itemize}
        \item manche Transformationen sollten immer angewendet werden (etwa $\sin^2(x) + \cos^2(x) \rightarrow 1)$
        \item andere Transformationen nur ausprobieren und mit einer passenden Metrik gucken, wie gut ein Term nach Anwendung noch weiter vereinfacht werden kann (etwa, wenn man aus verschiedenen Optionen des Ausklammerns wählen kann)
        \item vielleicht Linearfaktorzerlegung von Polynomen (schätze ich für den allgemeinen Fall schwierig ein, solange ich nur exakte Operationen zulasse)
        \item vielleicht Polynomdivision (schätze ich genau so schwierig ein, zumindest wenn ich nicht vorher schon Linearfaktoren habe)
        \item \dots
    \end{itemize}
\end{enumerate}
~\\~
Anmerkung 1: Die Normalform ist notwendig, um zu garantieren, dass mehrfaches Auftreten eines Teilbaums / Teilterms auch erkannt wird. \\
Anmerkung 2: es kann sein, dass ich manche Eigenschaften der Normalformauch während des Vereinfachungsschrittes immer wieder wiederherstellen muss.

\subsection{Vergleich meiner Features mit anderen Computeralgebrasystemen}
Ich bin ja nicht der erste, der auf die Idee kommt, Terme zusammenzufassen. Wolphram Alpha und Maple sind zwar nicht Open Source, aber andere Optionen, wie etwa SymPy aus der Python Standardbibliothek soweit ich weiß schon. Da lässt sich bestimmt ein bisschen vergleichen, wie andere Leute die selben Probleme lösen.

\section{Zusammenfassung}
Was halt in eine Zusammenfassung kommt

%\bibliographystyle{plain}
%\bibliography{references}
\end{document}
